<link rel="import" href="../polymer/polymer.html">


<link rel="import" href="../th-data-table/th-data-table.html">


<link rel="import" href="../th-component-list/th-component-list.html">

<polymer-element name="lenses-freeform" attributes="">
  <template>
    <link rel="stylesheet" href="lenses-freeform.css">

    <core-icon-button id="showDataBtn" class="active" icon="view-module" on-click="{{showDataBtn}}" alt="show component data">
      <span>show component input/output</span>
    </core-icon-button>


    <label class="component-list-label">Drag components into canvas:</label>
    <th-component-list id="component_list"></th-component-list>

    <div id="input_preview" class="data-preview">
      <template if="{{_showDataTable && _selElement.input && _selElement.input.length>0}}">
        <label>INPUT</label>
        <th-data-table id="input_table" input="{{_selElement.input}}" class="table"  minimal="true"></th-data-table>
      </template>
    </div>

    <div id="container"  on-drop="{{droppedInContainer}}">
      <svg id="svg"></svg>


      <!-- Components and connector dots --> 
      <!--<template if="{{_positioned}}">-->

        <template repeat="{{el, index in _elements}}">
          <div class="wrapper {{el.name}}" id="wrapper-{{el.element.id}}" on-click="{{wrapperClicked}}" style="top: {{el.top}}px; left: {{el.left}}px" on-click="{{wrapperClicked}}" on-dragStart="{{dragStartWrapper}}" on-drag="{{dragWrapper}}" on-dragend="{{dragEndWrapper}}" draggable="true" on-drop="{{droppedOnInArrow}}">

          
            <label>{{el.name}}</label>
            <!--<core-icon-button icon="clear" class="deleteEl {{el.element.id}}" on-click="{{_deleteElement}}"></core-icon-button> -->
            <div  class="deleteEl" component_id="{{el.element.id}}" on-click="{{_deleteElement}}">X</div>
             
            <div class="connectors-in" >
              <!-- Input -->
              
              <ul>
                <template repeat="{{ins in el.element.publish | _checkForInputAttr}}">
                     
                    <li class="{{el.element.id}}-{{ins}} arrow in-arrow" on-dragover="{{dragOverInArrow}}" 
                    on-drop="{{droppedOnInArrow}}" on-dragenter="{{dragEnterInArrow}}" on-dragleave="{{dragLeaveInArrow}}" on-click="{{arrowClicked}}">
                      <div class="inputMarker">
                        <span class="drop-zone"></span>
                      </div>
                      <!--{{ins}}-->
                    </li>
                </template>
              </ul>

              <!-- Output -->
            </div>
            <content select="#{{el.id}}"></content>
            <div class="connectors-out" >
              <template if="{{el.element.publish | _checkForOutputAttr}}">
                <div id="{{index}}"  class="{{el.element.id}} arrow out-arrow" 
                  on-drag="{{dragOutArrow}}" on-dragStart="{{dragOutArrowStart}}" on-dragEnd="{{dragOutArrowEnd}}"  
                   on-click="{{arrowClicked}}" draggable="true">
                  <div class="outputMarker"></div>
                </div>
              </template>
              
            </div>
            <template if="{{el.resizable}}">
              <div class="resize" draggable="true" ></div>
            </template>
          
          </div>
        </template>
      <!--</template>-->
    </div> 

    <div id="output_preview" class="data-preview">
      <template if="{{_showDataTable && _selElement.output && _selElement.output.length>0}}">
        <label>OUTPUT</label>
        <th-data-table id="output_table" input="{{_selElement.output}}" class="table"  minimal="true"></th-data-table>
      </template>
    </div>       

    
  </template>
  <script>
    Polymer({

      _elements: [],
      _connections: [],

      _selElement: null,

      _snapX: 10,
      _snapY: 10,
      _showDataTable: true,


      domReady: function() {

        
          this.addEventListener('core-resize', function() {
            this._drawConnections();
          });



      },


      addNewElToConnector: function(newElName, left, top){


        newEl = document.createElement(newElName);

        this.$.component_list.checkAndImport(newEl, function() {

          // newEl.setAttribute('_top', top);
          // newEl.setAttribute('_left', left);


          newEl.style.width = '100%';
          newEl.style.height = '100%';



          this.appendChild(newEl);

          this._processNewElement(newEl, top, left);

        }.bind(this));


      }, 

      _processNewElement: function(newEl, top, left) {

          newEl.id = this._generateUniqueId(newEl.tagName.toLowerCase());


          var elItem = {  element: newEl, 
                                        id: newEl.id,
                                        name: newEl.tagName.toLowerCase(), 
                                        top: top,
                                        left: left
                                    };


          var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());
          if(info.resizable || info.category==='visualize') {
            elItem.resizable = true;
          }

          this._elements.push(elItem);
          

          console.log('this._elements',this._elements);



      },

        _deleteElement: function(e) {

          if(confirm('Do you want to remove this element from the sketch?')) {

            var self = this;
            var compId = e.target.getAttribute('component_id');
            var ebmededEl = self.querySelector('#'+compId);
            var elInArray = self.findElById(compId);

            //remove all connections
            self.removeAllConnectionsFromElement(compId)

            // remove element from elements array (which removes it from the shadowDOM)
            var filteredEls = self._elements.filter(function(el) {
                return el.element.id!==compId;
            });
            self._elements = filteredEls;

            // remove elements from th-connector 
            self.removeChild(ebmededEl);
          }


        },

        removeAllConnectionsFromElement: function(elId) {

          var goodConnections = this._connections.filter(function (conn, index) {
            
            //filter if element is source or target of a connection
            return !(conn.source.id===elId || conn.target.id === elId)
             
          });

          this._connections = goodConnections;

          this._drawConnections();


        },              

      droppedInContainer: function(e, detail, selection){
        console.log('droppedInContainer....');
        var self = this;

        var dataTransfer = e.dataTransfer.getData('text/plain');

        //data added by th-component-list //TODO make better
        if(dataTransfer && dataTransfer.length>0) {
          var dataSeg = dataTransfer.split(',');


          if(dataSeg.length==1) {
            self.addNewElToConnector(dataSeg[0], Math.round(e.offsetX/10)*10, Math.round(e.offsetY/10)*10);

            return;
          } 

        }

      },      

      dragResize: function(e, details, selection) {

          var self = this;

          console.log('dragResize');

          var wrapper = selection.parentNode;
          //var styles = window.getComputedStyle(wrapper);
          // var wrapperTop = parseInt(styles.top.replace('px',''));
          // var wrapperLeft = parseInt(styles.left.replace('px',''));

          // var w =  e.x - wrapperLeft - 65,
          //     h = e.y - wrapperTop - 172;

          var wrapperTop = parseInt(wrapper.getBoundingClientRect().top),
              wrapperLeft = parseInt(wrapper.getBoundingClientRect().left);
          

          var w =  e.x - wrapperLeft,
              h = e.y - wrapperTop;


           wrapper.style.width = w +'px';
           wrapper.style.height = h +'px';

          var elementInsideId = wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);


          self._drawConnections();

          e.stopPropagation();
          e.preventDefault();

        },
/*
        dragResizeEnd: function(e, details, selection) {
          
          var wrapper = selection.parentNode;

          var elementInsideId = wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);

          if(typeof elementInside.resize ==='function') {
            elementInside.resize();
          }

        },
*/

        dragStartWrapper: function(e, details, selection) {
          
          
          console.log('start', e, details, selection);


          //if resize is being dragged don't do anything (stopPropagation is not doing anything)
          
          // if(e.path[0].classList && e.path[0].classList.length>0 && e.path[0].classList.contains('resize')) {
          //   return false;
          // }

          var target = e.target;
          target.setAttribute('start-x', e.x);
          target.setAttribute('start-y', e.y);

          var dragImgEl = document.createElement('span');
          dragImgEl.setAttribute('style','opacity: 0' );
          dragImgEl.textContent = 'a';

          // add it to the document
          document.body.appendChild(dragImgEl);
          e.dataTransfer.setDragImage(dragImgEl,-200,-200);          
          
        },                            

        dragWrapper: function(e, details, selection) {

          if(e.path[0].classList && e.path[0].classList.length>0 && 
            (e.path[0].classList.contains('resize') || e.path[0].classList.contains('arrow'))) {
            return false;
          }

          var target = e.target,
              dx = e.x - (target.getAttribute('start-x') || 0),
              dy = e.y - (target.getAttribute('start-y') || 0);


              // keep the dragged position in the data-x/data-y attributes, add snap residue from previous drag
              var x = (parseFloat(target.getAttribute('data-x')) || 0) + dx + (parseFloat(target.getAttribute('residue-x')) || 0);
              var y = (parseFloat(target.getAttribute('data-y')) || 0) + dy + (parseFloat(target.getAttribute('residue-y')) || 0);

              sx = Math.round(x/this._snapX)*this._snapX;
              sy = Math.round(y/this._snapY)*this._snapY;

              target.setAttribute('residue-x', x - sx );
              target.setAttribute('residue-y', y - sy);


              // translate the element. 
              // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
              if(e.x!==0 ||  e.y!==0)
              {
              
                target.style.webkitTransform =
                target.style.transform = 'translate(' + sx + 'px, ' + sy + 'px)';

                // update the posiion attributes
                // 
                target.setAttribute('data-x', sx);
                target.setAttribute('data-y', sy);
                

                target.setAttribute('start-x', e.x);
                target.setAttribute('start-y', e.y);

                this._drawConnections();

              }
                
            
        }, 

        dragEndWrapper: function(e, details, selection) {
          
          
          //if resize is being dragged don't do anything (stopPropagation is not doing anything)
          // if(e.path[0].classList && e.path[0].classList.length>0 && e.path[0].classList.contains('resize')) {
          //   return false;
          // }

          var target = e.target;
          target.setAttribute('residue-x', 0 );
          target.setAttribute('residue-y', 0);

          
        }, 

        wrapperClicked: function(e, detail, selection) {
          var wrapperEl = selection;
          if(this._selWrapper) {
            this._selWrapper.classList.remove('selected-element');
          }
          this._selWrapper = wrapperEl;
          this._selWrapper.classList.add('selected-element');

          var elementId = wrapperEl.id;
          elementId = elementId.substring(8, elementId.length);

          this._selElement = this.findElById(elementId).element;

          // if(this.$.input_table) {
          //   this.$.input_table.input = this._selElement.input;
          // }
          // if(this.$.output_table) {
          //   this.$.output_table.input = this._selElement.output;
          // }

        },         

        dragOutArrowStart: function(e, details, selection) {

          this.draggedEl = selection;
          //to stop wrapper drag to be called
          e.stopPropagation();

          if(!this.svgTop || !this.svgLeft) {

            var svgRect = this.$.svg.getBoundingClientRect();
            this.svgTop = svgRect.top;
            this.svgLeft = svgRect.left;

          }


          this.startPointX = e.x - this.svgLeft;
          this.startPointY = e.y - this.svgTop;

          // create temp bezier
          this._addBezierPath( this.startPointX , this.startPointY , this.startPointX , this.startPointY , 70, 'temp_path');
          //this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70, 'temp_path');

        },

        dragOutArrow: function(e, details, selection) {

          var tempPath = this.shadowRoot.querySelector('#temp_path');

          // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
          if(e.x!==0 ||  e.y!==0)
          {

            var newPath = this._createBezierPath( this.startPointX, this.startPointY , e.x - this.svgLeft  , e.y - this.svgTop  , 70);
            tempPath.setAttribute('d',newPath);
          }               

        },

        dragOutArrowEnd: function(e, details, selection) {

          var tempPath = this.shadowRoot.querySelector('#temp_path');
          if(tempPath) {
            tempPath.parentNode.removeChild(tempPath);
          }
               

        },

        dragOverInArrow: function(e, details, selection) {

          //console.log('dragOverInArrow', e);
          
          //important! needed to allow drop
          e.preventDefault();

        },  

        dragEnterInArrow: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },                  

        dragLeaveInArrow: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },                  

        droppedOnInArrow: function(e, details, selection) {

          var self = this;

          e.target.classList.remove('drag-over');

          var className = selection.classList[0],
              targetElementId = className.substring(0, className.lastIndexOf('-') ),   
              targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),      
              source = self.findElById(self.draggedEl.classList[0]),
              target = self.findElById(targetElementId);

          console.log(selection.classList[0],targetElementId,targetField,target);


          this._connectAttributes(source, 'output', target, targetField);

        // self._connections.push({source: source, target: target});

        // }

          self._drawConnections();

          e.stopPropagation();          

        }, 

        arrowClicked: function(e, details, selection) {
          console.log(e);
          e.stopPropagation();
        },      

        showDataBtn: function() {
            this._showDataTable = !this._showDataTable;
            this.$.showDataBtn.classList.toggle('active');
            [].forEach.call(this.shadowRoot.querySelectorAll('.data-preview'), function(el) {
              console.log(el.style.maxHeight,el.style.opacity);
              el.style.maxHeight = el.style.maxHeight=='0px' ? '100px' : '0px';
            });
        },







        /**
         * The functions which sets the connection (two way binging) between two element attrubutes
         * There is not really a sourc/target distinction in the observer since it is a two way binging (in theory)
         * but the distinction is conceptual and in UI.
         * @param  {[type]} source      Source element
         * @param  {[type]} sourceField The attribute to connect from source element
         * @param  {[type]} target      Target element
         * @param  {[type]} targetField The attribute to connect from target element
         * @return {None}             
         */
        _connectAttributes: function(source, sourceField, target, targetField) {
          var self = this;

          //find the index of connection which has the same target
          var connWithSameTargetIndex = self._connections.reduce(function(value, conn, index) {
              console.log(conn);
              if (conn.target.id===target.id && conn.target.field===targetField) {
                return index;
              }

          }, -1);
          // and remove it from connections array
          if(connWithSameTargetIndex>-1) {
            self._connections.splice(connWithSameTargetIndex,1);
          }


          if (source === target){ //if a bubble was dropped on itself
            alert('You cannot make a connection within the same element');
            return false;
          } else { 

            // make the connection in the elements array
            //target.inputConnectedTo = source;  // not needed
              
            var observer = new PathObserver(source.element, sourceField);  
              
            observer.open(function(newValue, oldValue) {
               target.element[targetField] = newValue;
            });

            var srcClone = {id: source.id, name: source.name, element: source.element};
            var targetClone = {id: target.id, name: target.name, element: target.element};


            
            target.element[targetField] = source.element[sourceField]; 

            targetClone.field = targetField;

            //self.updateConnections();
            
            //push the connections anyways because it will be deleted above.
            self._connections.push({source: srcClone, target: targetClone});

            
            return true;
          }

        },

        _drawConnections: function() {

          var self = this;


          var arrowOffsetY = 7;
          var arrowOffsetX = 7;
          var bezierCurveX = 70;  // the larger the value the smoother the curve


          //clear all paths. since it is not done offten it is fine to do it in a not optimized way
          self.$.svg.innerHTML = '';

          for (var i = 0; i < self._connections.length; i++) {


            var conn = self._connections[i];

            console.log('connection ', conn);


            var srcEl = conn.source.element || self.querySelector('#'+conn.source.id); //TODO do this in initialization method
            var targetEl = conn.target.element || self.querySelector('#'+conn.target.id);


            var srcWrapper = self.shadowRoot.querySelector('#wrapper-'+srcEl.id);
            var targetWrapper = self.shadowRoot.querySelector('#wrapper-'+targetEl.id);


            // var srcRect = srcEl.getBoundingClientRect();
            // var targetRect = targetEl.getBoundingClientRect();

            var srcRect = srcWrapper.getBoundingClientRect();
            var targetRect = targetWrapper.getBoundingClientRect();


            var svgRect = self.$.svg.getBoundingClientRect();

            var otherInputOffset = (conn.target.field==='input') ? 0 : 16;

            var startX = srcRect.right - svgRect.left + arrowOffsetX; //srcRect.left + srcRect.width + 30 - containerOffsetX;
            var startY = srcRect.top - svgRect.top + arrowOffsetY;
            var endX = targetRect.left  - svgRect.left - arrowOffsetX;
            var endY = targetRect.top  - svgRect.top + arrowOffsetY + otherInputOffset;


            self._addBezierPath(startX, startY, endX, endY , bezierCurveX);
            
          }        

        },

        findElById: function(id){
          var self = this;
          element = self._elements.filter(function(el){
            return el.id === id;
          })[0];

          return element;
        },




      _checkForInputAttr: function(value){
        var attrs = Object.keys(value).filter(function(item) {
          return item.indexOf("input") > -1;

        })
        return attrs;
        //return value && Object.keys(value).indexOf("input") > -1 ? true : false;
      },
      _checkForOutputAttr: function(value){
        return value && Object.keys(value).indexOf("output") > -1 ? true : false;
      },
      _generateUniqueId: function(elName){
          var self = this;
          var num = 0;
          var tagsWithSameName = self._elements.filter(function(elem){return elem.name == elName});
          
          if(tagsWithSameName){
            num+= tagsWithSameName.length;
          } 
          
          var uniqueId = elName + '-' + num;
          
          return uniqueId;
      }, 





      _createBezierPath: function(startX, startY, endX, endY, handleOffsetX) {

          // make handleOffsetX larger when source element is on the right side of target
          if(startX > endX) {
            handleOffsetX *= 2;
          }
          var distance = Math.sqrt(Math.pow(endX-startX, 2) + Math.pow(endY-startY,2));
          // decrease handleOffsetX when too close...
          if(distance<100) {
             handleOffsetX /= 2;
          }
          if(distance<50) {
             handleOffsetX /= 4;
          }
          var path = "M"+parseInt(startX)+","+parseInt(startY)+
                     " C"+parseInt(startX + handleOffsetX)+","+parseInt(startY)+
                     " "+parseInt(endX - handleOffsetX)+","+parseInt(endY)+
                     " "+parseInt(endX)+","+parseInt(endY);
          return path;
      },

      _addBezierPath: function(startX, startY, endX, endY, handleOffsetX, id) {

          var aLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
          var path = this._createBezierPath(startX, startY, endX, endY, handleOffsetX);

          aLine.setAttribute('d',path);
          aLine.setAttribute('stroke', '#555');// conn.source.color);
          aLine.setAttribute('fill', 'none');
          if(id) {
            aLine.setAttribute('id', id);
          }
          

          this.$.svg.appendChild(aLine);

      },



     
    });
  </script>
</polymer-element>
