<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../th-component-list/th-component-list.html">

<polymer-element name="lenses-freeform" attributes="">
  <template>
    <link rel="stylesheet" href="lenses-freeform.css">

    <th-component-list id="component_list"></th-component-list>

    <div id="container" on-dragover="{{dragOver}}" on-drop="{{droppedInContainer}}">
      <svg id="svg"></svg>


      <!-- Components and connector dots --> 
      <!--<template if="{{_positioned}}">-->

        <template repeat="{{el, index in _elements}}">
          <div class="wrapper {{el.name}}" id="wrapper-{{el.element.id}}" on-click="{{wrapperClicked}}" style="top: {{el.top}}px; left: {{el.left}}px" on-click="{{wrapperClicked}}" on-dragStart="{{dragStartWrapper}}" on-drag="{{dragWrapper}}" on-dragend="{{dragEndWrapper}}" draggable="true">

          
            <label>{{el.name}}</label>
            <!--<core-icon-button icon="clear" class="deleteEl {{el.element.id}}" on-click="{{_deleteElement}}"></core-icon-button> -->
            <div  class="deleteEl" component_id="{{el.element.id}}" on-click="{{_deleteElement}}">X</div>
             
            <div class="connectors-in" >
              <!-- Input -->
              
              <ul>
                <template repeat="{{ins in el.element.publish | _checkForInputAttr}}">
                     
                    <li class="{{el.element.id}}-{{ins}} arrow in-arrow" ondragover="{{dragOverInArrow}}" ondrop="{{droppedOnInArrow}}">
                      <div class="inputMarker"></div>
                      <!--{{ins}}-->
                    </li>
                </template>
              </ul>

              <!-- Output -->
            </div>
            <content select="#{{el.id}}"></content>
            <div class="connectors-out" >
              <template if="{{el.element.publish | _checkForOutputAttr}}">
                <div id="{{index}}"  class="{{el.element.id}} arrow out-arrow" draggable="true">
                  <div class="outputMarker"></div>
                </div>
              </template>
              
            </div>
            <template if="{{!el.resizable}}">
              <div class="resize" draggable="true" ></div>
            </template>
          
          </div>
        </template>
      <!--</template>-->
    </div>    

    <content></content>
  </template>
  <script src="../interact/interact.js"></script>
  <script>
    Polymer({

      _elements: [],

      _snapX: 10,
      _snapY: 10,

      domReady: function() {

        /*
        
        interact('.wrapper')
          .draggable({
            snap: {
                  targets: [
                    interact.createSnapGrid({ x: 10, y: 10 })
                  ],
                  range: Infinity,
                  elementOrigin: { x: 0, y: 0 }

            },
    
            inertia: false,
            // keep the element within the area of it's parent
     
            // call this function on every dragmove event
            onmove: function (event) {

              console.log(event);
              
              var target = event.target,
                  // keep the dragged position in the data-x/data-y attributes
                  x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                  y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

              // translate the element
              target.style.webkitTransform =
              target.style.transform =
                'translate(' + x + 'px, ' + y + 'px)';

              // update the posiion attributes
              target.setAttribute('data-x', x);
              target.setAttribute('data-y', y);
              
            },
            // call this function on every dragend event
            onend: function (event) {
              
            }
          });
*/
/*
        interact('.resize')
          .draggable({
 
    
            inertia: false,
            onmove: function (event) {

              
            },
            // call this function on every dragend event
            onend: function (event) {
              console.log('RESIZE', event);

              var target = event.target,
                  // keep the dragged position in the data-x/data-y attributes
                  x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
                  y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;

              var wrapper = target.parentNode;

              var computedStyles = window.getComputedStyle(wrapper, null);
              

              wrapperWidth = computedStyles.getPropertyValue('width'); //wrapper.style.width.replace('px', '') || wrapper.style.minWidth.replace('px', '') || 100;
              wrapperHeight = computedStyles.getPropertyValue('height');//wrapper.style.height.replace('px', '') || wrapper.style.minHeight.replace('px', '') || 40;

              console.log(wrapperWidth, wrapperHeight, event.dx, event.dy, wrapper, wrapper.style);

              // translate the element
              wrapper.style.width = parseFloat(wrapperWidth) + parseFloat(event.dx) + 'px'
              wrapper.style.height = parseFloat(wrapperHeight) + parseFloat(event.dy) + 'px'

              console.log(wrapper.style.width, wrapper.style.height);

            
            }
          });

*/

        // interact('.out-arrow')
        //   .draggable({
        //     onstart: function(event) {

        //       console.log('arrow start', event);

        //       this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70, 'temp_path');
        //     }.bind(this),
        //     onmove: function (event) {

            

        //     var target = event.target,
        //         // keep the dragged position in the data-x/data-y attributes
        //         x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx,
        //         y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;
      
        //     // translate the element
        //     target.style.webkitTransform =
        //     target.style.transform =
        //       'translate(' + x + 'px, ' + y + 'px)';
      
        //     // update the posiion attributes
        //     target.setAttribute('data-x', x);
        //     target.setAttribute('data-y', y);    

                      

        //       var tempPath = this.shadowRoot.querySelector('#temp_path');

             

        //       var newPath = this._createBezierPath( event.x0 , event.y0 , event.clientX , event.clientY , 70);
        //       tempPath.setAttribute('d',newPath);

              
        //     }.bind(this),
        //     // call this function on every dragend event
        //     onend: function (event) {
             
        //       var tempPath = this.shadowRoot.querySelector('#temp_path');
        //       if(tempPath) {
        //         tempPath.parentNode.removeChild(tempPath);
        //       }


            
        //     }.bind(this)
        //   });

          /*

          interact('.in-arrow').dropzone({
            // only accept elements matching this CSS selector
            //accept: '.out-arrow',
            // Require a 75% element overlap for a drop to be possible
            overlap: 0.5,

            // listen for drop related events:

            ondropactivate: function (event) {
              // add active dropzone feedback
              console.log('ondropactivate', event);
              event.target.classList.add('drop-active');
            },
            ondragenter: function (event) {
              
              console.log('enter', event);

              var draggableElement = event.relatedTarget,
                  dropzoneElement = event.target;

              // feedback the possibility of a drop
              dropzoneElement.classList.add('drop-target');
              draggableElement.classList.add('can-drop');
              draggableElement.textContent = 'Dragged in';
            },
            ondragleave: function (event) {

              console.log('leave', event);

              // remove the drop feedback style
              event.target.classList.remove('drop-target');
              event.relatedTarget.classList.remove('can-drop');
              event.relatedTarget.textContent = 'Dragged out';
            },
            ondrop: function (event) {

              console.log('drop', event);

              this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70);

              event.relatedTarget.textContent = 'Dropped';
            },
            ondropdeactivate: function (event) {
              // remove active dropzone feedback
              event.target.classList.remove('drop-active');
              event.target.classList.remove('drop-target');
            }
          });

        */


      },

      droppedInContainer: function(e, detail, selection){
        console.log('droppedInContainer');
        var self = this;

        var dataTransfer = e.dataTransfer.getData('text/plain');


        if(dataTransfer && dataTransfer.length>0) {
          var dataSeg = dataTransfer.split(',');
        }


        if(dataSeg.length==1) {
          self.addNewElToConnector(dataSeg[0], Math.round(e.offsetX/10)*10, Math.round(e.offsetY/10)*10);

          return;
        }  
      },
      addNewElToConnector: function(newElName, left, top){


        newEl = document.createElement(newElName);

        this.$.component_list.checkAndImport(newEl, function() {

          // newEl.setAttribute('_top', top);
          // newEl.setAttribute('_left', left);


          newEl.style.width = '100%';
          newEl.style.height = '100%';

          this.appendChild(newEl);

          this._processNewElement(newEl, top, left);

        }.bind(this));


      }, 

      _processNewElement: function(newEl, top, left) {

          newEl.id = this._generateUniqueId(newEl.tagName.toLowerCase());

          var elItem = {  element: newEl, 
                                        id: newEl.id,
                                        name: newEl.tagName.toLowerCase(), 
                                        top: top,
                                        left: left
                                    };
          this._elements.push(elItem);
          

          console.log('this._elements',this._elements);



      },
      _checkForInputAttr: function(value){
        var attrs = Object.keys(value).filter(function(item) {
          return item.indexOf("input") > -1;

        })
        return attrs;
        //return value && Object.keys(value).indexOf("input") > -1 ? true : false;
      },
      _checkForOutputAttr: function(value){
        return value && Object.keys(value).indexOf("output") > -1 ? true : false;
      },
      _generateUniqueId: function(elName){
          var self = this;
          var num = 0;
          var tagsWithSameName = self._elements.filter(function(elem){return elem.name == elName});
          
          if(tagsWithSameName){
            num+= tagsWithSameName.length;
          } 
          
          var uniqueId = elName + '-' + num;
          
          return uniqueId;
      }, 

      dragResize: function(e, details, selection) {

          var self = this;

          console.log('dragResize');

          var wrapper = selection.parentNode;
          //var styles = window.getComputedStyle(wrapper);
          // var wrapperTop = parseInt(styles.top.replace('px',''));
          // var wrapperLeft = parseInt(styles.left.replace('px',''));

          // var w =  e.x - wrapperLeft - 65,
          //     h = e.y - wrapperTop - 172;

          var wrapperTop = parseInt(wrapper.getBoundingClientRect().top),
              wrapperLeft = parseInt(wrapper.getBoundingClientRect().left);
          

          var w =  e.x - wrapperLeft,
              h = e.y - wrapperTop;


           wrapper.style.width = w +'px';
           wrapper.style.height = h +'px';

          var elementInsideId = wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);


          self._drawConnections();

          e.stopPropagation();
          e.preventDefault();

        },
/*
        dragResizeEnd: function(e, details, selection) {
          
          var wrapper = selection.parentNode;

          var elementInsideId = wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);

          if(typeof elementInside.resize ==='function') {
            elementInside.resize();
          }

        },
*/
        dragOverInArrow: function(e, details, selection) {

          console.log('dragOverInArrow', e);

        },                     

        droppedOnInArrow: function(e, details, selection) {

          console.log('droppedOnInArrow', e);

        }, 

        dragStartWrapper: function(e, details, selection) {
          
          
          console.log('start', e, details, selection);


          //if resize is being dragged don't do anything (stopPropagation is not doing anything)
          
          // if(e.path[0].classList && e.path[0].classList.length>0 && e.path[0].classList.contains('resize')) {
          //   return false;
          // }

          var target = e.target;
          target.setAttribute('start-x', e.x);
          target.setAttribute('start-y', e.y);

          var dragImgEl = document.createElement('span');
          dragImgEl.setAttribute('style','opacity: 0' );
          dragImgEl.textContent = 'a';

          // add it to the document
          document.body.appendChild(dragImgEl);
          e.dataTransfer.setDragImage(dragImgEl,-200,-200);          
          
        },                            

        dragWrapper: function(e, details, selection) {

          var target = e.target,
              dx = e.x - (target.getAttribute('start-x') || 0),
              dy = e.y - (target.getAttribute('start-y') || 0);


              // keep the dragged position in the data-x/data-y attributes, add snap residue from previous drag
              var x = (parseFloat(target.getAttribute('data-x')) || 0) + dx + (parseFloat(target.getAttribute('residue-x')) || 0);
              var y = (parseFloat(target.getAttribute('data-y')) || 0) + dy + (parseFloat(target.getAttribute('residue-y')) || 0);

              sx = Math.round(x/this._snapX)*this._snapX;
              sy = Math.round(y/this._snapY)*this._snapY;

              target.setAttribute('residue-x', x - sx );
              target.setAttribute('residue-y', y - sy);


              // translate the element. 
              // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
              if(e.x!==0 ||  e.y!==0)
              {
              
                target.style.webkitTransform =
                target.style.transform = 'translate(' + sx + 'px, ' + sy + 'px)';

                // update the posiion attributes
                // 
                target.setAttribute('data-x', sx);
                target.setAttribute('data-y', sy);
                

                target.setAttribute('start-x', e.x);
                target.setAttribute('start-y', e.y);

              }
                
            
        }, 

        dragEndWrapper: function(e, details, selection) {
          
          
          console.log('start', e, details, selection);


          //if resize is being dragged don't do anything (stopPropagation is not doing anything)
          if(e.path[0].classList && e.path[0].classList.length>0 && e.path[0].classList.contains('resize')) {
            return false;
          }

          /*
          var style = window.getComputedStyle(e.target, null),
              left = parseInt(style.getPropertyValue("left"),10),
              top = parseInt(style.getPropertyValue("top"),10);

          //if position left/top doens't exist 0 instead of NaN
          var offset_data = ((isNaN(left) ? 0 : left) - e.clientX) +
                        ',' + ((isNaN(top) ? 0 : top) - e.clientY) +
                        ',' + selection.id;
          e.dataTransfer.setData("text/plain",offset_data);

          */
         
          var target = e.target;
         // target.setAttribute('start-x',0);
         // target.setAttribute('start-y',0);
         // 
              target.setAttribute('residue-x', 0 );
              target.setAttribute('residue-y', 0);

          
        },           

        _createBezierPath: function(startX, startY, endX, endY, handleOffsetX) {

            // make handleOffsetX larger when source element is on the right side of target
            if(startX > endX) {
              handleOffsetX *= 2;
            }
            var distance = Math.sqrt(Math.pow(endX-startX, 2) + Math.pow(endY-startY,2));
            // decrease handleOffsetX when too close...
            if(distance<100) {
               handleOffsetX /= 2;
            }
            if(distance<50) {
               handleOffsetX /= 4;
            }
            var path = "M"+parseInt(startX)+","+parseInt(startY)+
                       " C"+parseInt(startX + handleOffsetX)+","+parseInt(startY)+
                       " "+parseInt(endX - handleOffsetX)+","+parseInt(endY)+
                       " "+parseInt(endX)+","+parseInt(endY);
            return path;
        },

        _addBezierPath: function(startX, startY, endX, endY, handleOffsetX, id) {

            var aLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
            var path = this._createBezierPath(startX, startY, endX, endY, handleOffsetX);

            aLine.setAttribute('d',path);
            aLine.setAttribute('stroke', '#555');// conn.source.color);
            aLine.setAttribute('fill', 'none');
            if(id) {
              aLine.setAttribute('id', id);
            }
            

            this.$.svg.appendChild(aLine);

        },



     
    });
  </script>
</polymer-element>
