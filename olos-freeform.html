<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-splitter/core-splitter.html">

<!-- used to show multiple methods in code-editor -->
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-dropdown/paper-dropdown.html">
<link rel="import" href="../paper-item/paper-item.html">

<link rel="import" href="../olos-component-list/olos-component-list.html">
<link rel="import" href="../olos-code-editor/olos-code-editor.html">


<link rel="import" href="../olos-doc-viewer/olos-doc-viewer.html">

<link rel="import" href="../paper-dialog/paper-dialog.html">


<link rel="stylesheet" href="colors.css">

<polymer-element name="olos-freeform" attributes="" on-keydown="{{keydownHandler}}" on-keypress="{{keypressHandler}}">
  <template>
    <link rel="stylesheet" href="olos-freeform.css">
    <link rel="stylesheet" href="colors.css">

    <!-- header -->
    <core-toolbar class="small">

      <paper-input-decorator label="Enter a name">
       <input id="filename" is="core-input">
       </paper-input-decorator>

<!--       <paper-icon-button id="new"
        icon="autorenew"></paper-icon-button>
      <paper-icon-button id="undo"
        icon="undo"></paper-icon-button>
      <paper-icon-button id="redo"
        icon="redo"></paper-icon-button>
 -->
      <paper-icon-button id="save"
        icon="save"></paper-icon-button>
      <paper-icon-button id="open"
        icon="folder"></paper-icon-button>
      <paper-icon-button id="info"
        icon="info-outline"></paper-icon-button>

      <paper-icon-button id="clear"
        icon="clear" on-click={{_environmentClear}}></paper-icon-button>

      <paper-icon-button id="morebutton"
        icon="more-vert"></paper-icon-button>

    </core-toolbar>


    <core-icon-button id="showDataBtn" class="active" icon="view-module" on-click="{{showDataBtn}}" alt="show component data">
      <span>show code</span>
    </core-icon-button>


      <paper-dialog id="codeDialog" backdrop transition="core-transition-center" heading="var {{_selElement.varName}}">
          <label>Current Method: </label>
          <paper-dropdown-menu id="methodDropdown" label="{{_selectedMethod}}">
            <paper-dropdown class="dropdown">
              <core-menu selected="0" id="selector" on-core-select="{{_methodChanged}}" class="menu">
                <template repeat="{{meth, index in _publicMethods}}">
                  <paper-item label="{{meth}}">{{meth}}</paper-item>
                </template>
              </core-menu>
            </paper-dropdown>
          </paper-dropdown-menu>
        </div>
        <olos-code-editor id="codeeditor"></olos-code-editor>
    </paper-dialog>

    <paper-dialog id="infoDialog" backdrop transition="core-transition-center" heading="var {{_selElement.varName}}">
      <!-- <olos-doc-viewer flex style=" position:fixed; right:0px; top: 400px; width:350px; height:600px; background-color:#fdffdf" id="docViewer"> -->

      <olos-doc-viewer flex style="width:720px; height:600px; background-color:#fdffdf" id="docViewer">

      </olos-doc-viewer>
    </paper-dialog>


      <label class="component-list-label">Drag components into canvas:</label>
      <olos-component-list id="component_list"></olos-component-list>

      <div class="destBar" vertical layout>
        <div id="destino" width="300" height="30">
          <!-- destination -->
          <template repeat="{{destination in destinations}}">
            <div class="wrapper" id="wrapper" on-click="{{wrapperClicked}}" draggable="false">
            <div class="wrapper {{destination.name}} {{destination.colorClass + '2'}}" id="wrapper-{{destination.element.id}}" component-id="{{destination.element.id}}" on-click="{{wrapperClicked}}" style="top: {{destination.top}}px; left: {{destination.left}}px; transform: {{destination.transform}}; width: {{destination.width}}px; height: {{destination.height}}px" on-click="{{wrapperClicked}}" on-dragStart="{{dragStartWrapper}}" on-drag="{{dragWrapper}}" on-dragend="{{dragEndWrapper}}" draggable="true"><!-- on-drop="{{droppedOnInArrow}}" needed? -->

              <!-- Input -->
              <div class="connectors-in" >
                <ul>
                  <template repeat="{{ins in destination.element.publish | _checkForInputAttr}}">
                    <li class="{{destination.element.id}}-{{ins}} arrow in-arrow" on-dragover="{{dragOverInArrow}}" 
                    on-drop="{{droppedOnInArrow}}" on-dragenter="{{dragEnterInArrow}}" on-dragleave="{{dragLeaveInArrow}}" on-mouseenter="{{dragEnterInArrow}}" on-mouseleave="{{dragLeaveInArrow}}" on-click="{{arrowClicked}}">
                      <svg class="inputMarkerSVG" viewBox="-20 0 20 20">
                        <ellipse cx="-15" cy="10" rx="5" ry="5"></ellipse>
                        <div class="delete" on-click="{{deleteConnection}}">x</div>
                      </svg>
                    <span class="drop-zone tooltip">{{ins}}
                    </span>
                    </li>
                  </template>
                </ul>
              </div>
            </div>
          </template>
        </div>
      </div> <!-- end dest bar -->


    <div id="container" on-mousedown="{{clickInContainer}}" on-drop="{{droppedInContainer}}" on-dragover="{{draggedOverContainer}}">

      <svg id="svg"></svg>

      <!-- Components and connector dots --> 
      <!--<template if="{{_positioned}}">-->


        <template repeat="{{el, index in _elements }}">
          <template if="{{el.id | noDest}}">

            <div class="wrapper {{el.name}} {{el.colorClass + '2'}}" id="wrapper-{{el.element.id}}" component-id="{{el.element.id}}" on-click="{{wrapperClicked}}" 
            style="top: {{el.top}}px; left: {{el.left}}px; transform: {{el.transform}}; width: {{el.width}}px; height: {{el.height}}px;" 
            on-click="{{wrapperClicked}}" on-dragStart="{{dragStartWrapper}}" on-drag="{{dragWrapper}}" on-dragend="{{dragEndWrapper}}" draggable="true"><!-- on-drop="{{droppedOnInArrow}}" needed? -->

            <div>
              <label class="{{el.colorClass + '3'}} labelTab" width="100%" style="overflow:hidden;">olos.{{el.varName}}</label>
            </div>

            <div class="{{el.colorClass + '4'}} codeTab" height="100%" width="30%" on-click="{{_elCodeButtonClicked}}">&lt &#92; &gt
            </div>

            <div  class="elInfo {{el.colorClass + '5'}}" component_id="{{el.element.id}}" on-click="{{_elInfoButtonClicked}}">i</div>

            <div  class="deleteEl {{el.colorClass + '4'}}" component_id="{{el.element.id}}" on-click="{{_deleteEvent}}">X</div>

            <!-- Input -->
            <div class="connectors-in" >
              <template repeat="{{ins in el.element.publish | _checkForInputAttr}}">
                <ul>
                    <li class="{{el.element.id}}-{{ins}} arrow in-arrow" on-dragover="{{dragOverInArrow}}" 
                    on-drop="{{droppedOnInArrow}}" on-dragenter="{{dragEnterInArrow}}" on-dragleave="{{dragLeaveInArrow}}" on-mouseenter="{{dragEnterInArrow}}" on-mouseleave="{{dragLeaveInArrow}}" on-click="{{arrowClicked}}">
                      <svg class="inputMarkerSVG" viewBox="-20 0 20 20">
                        <ellipse cx="-15" cy="10" rx="5" ry="5"></ellipse>
                      </svg>
                      <div class="delete" on-click="{{deleteConnection}}">x</div>
                    <span class="drop-zone tooltip">{{ins}}
                    </span>

                      <!--{{ins}}-->
                    </li>
                </ul>
              </template>
            </div>

            <!-- audioParams -->
            <div class="connectors-params">
              <template repeat="{{params in el.element.publish | _checkForAudioParams}}">
                <ul>
                  <li class="{{el.element.id}}-{{params}} arrow param-arrow" on-dragover="{{dragOverParamArrow}}" 
                  on-drop="{{droppedOnParamArrow}}" on-dragenter="{{dragEnterParamArrow}}" on-dragleave="{{dragLeaveParamArrow}}" on-mouseenter="{{dragEnterParamArrow}}" on-mouseleave="{{dragLeaveParamArrow}}" on-click="{{arrowClicked}}">
                    <!-- <div class="paramMarker"> -->
                      <svg class="paramMarkerSVG" viewBox="-20 0 20 20">
                      <ellipse cx="-10" cy="10" rx="5" ry="5"></ellipse>
                      </svg>
                      <div class="delete" on-click="{{deleteConnection}}">x</div>
                      <span class="drop-zone">{{params}}</span>

                    <!-- </div> -->
                  </li>
                </ul>
              </template>
            </div>

            <content select="#{{el.id}}"></content>

            <!-- Output -->
            <div class="connectors-out" >
              <template if="{{el.element.publish | _checkForOutputAttr}}">
                <div id="{{index}}"  class="{{el.element.id}} arrow out-arrow" 
                  on-drag="{{dragOutArrow}}" on-dragstart="{{dragOutArrowStart}}" on-dragend="{{dragOutArrowEnd}}"  
                   on-click="{{arrowClicked}}" draggable="true" style="z-index:100" >
                  <!-- <div class="outputMarker" style="z-index:101"></div> -->
                  <svg class="outputMarker" id="marker" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                     viewBox="9 0 20 15" enable-background="new 9 0 20 15" xml:space="preserve">

                <path d="M9.6,13.2c0.1-0.3,0.1-0.7,0.3-1c1.4-1.7,1.4-3,0-4.6C9.7,7.4,9.7,7,9.6,6.4C12.5,8.4,12.5,11.5,9.6,13.2z"/>
                <path d="M10.5,14.1c0.1-0.3,0.1-0.7,0.3-1c1.4-1.7,1.9-3.6,0.6-5.4c-1.6-2.3-1.1-2-1.2-2.6C13.1,7.2,13.4,12.4,10.5,14.1z"/>
                <path d="M8.9,12c0.2-0.7,0.6-1.4,0.6-2.1c0-0.6-0.4-1.3-0.5-2c1.8,1.1,1.9,2.8,0.2,4.2C9.2,12,9,12,8.9,12z"/>
                </svg>


                <!-- </div> -->
              </template>
            </div>

            <template if="{{el.resizable}}">
              <div class="resize" draggable="true" on-dragStart="{{dragStartResize}}" on-drag="{{dragResize}}" on-dragend="{{dragEndResize}}"></div>
            </template>
          
          </div>
          </template>

        </template>

    </div> <!-- end container-->

  </template>

  <script type="text/javascript" src="../p5js/lib/p5.js"></script>
  <script type="text/javascript" src="../p5js/lib/addons/p5.sound.js"></script>
  <script src="../Tone/Tone.js"type="text/javascript"></script>

  <script>

    PolymerExpressions.prototype.noDest = function(str) {
      var i = str.indexOf('destination') > -1 ? true : false;
      if (!i){
        return str;
      }
    };

    // set up global p5
    function setup() {
      noLoop();
      noCanvas();
    }

    // GLOBAL
    if (window.p5 && window.p5.soundOut) {
      var audioContext = p5.prototype.getAudioContext();
    } else {
      // TO DO: add shims
      audioContext = new AudioContext();
    }

    var _dragObj = {};

    Polymer({

      destinations: [],

      _elements: [],
      _connections: [],

      _selElement: undefined,
      _selectedMethod: null,
      _publicMethods: null,

      _snapX: 10,
      _snapY: 10,
      _showDataTable: false,

      // store all of the methods that have been overwritten
      // id: methodName: code
      _customMethods: {},

      // color scheme
      _colors: ['a', 'b', 'c', 'd'],

      domReady: function() {

          this.addEventListener('core-resize', function() {
            this._drawConnections();
          });

          var obj = ['olos-destination', '-1'];
          this.addNewElToConnector(obj, 0, 0);
      },

      ready: function() {
        // this.focus();
        this.tabIndex = 0;

        // assign olos variable to window
        window.olos = this;

      },

      addNewElToConnector: function(newEl, left, top){

        var newElName = newEl[0];
        var newElCategoryIndex = newEl[1];

        var newEl = document.createElement(newElName);
        newEl.name = newElName;

        this.$.component_list.checkAndImport(newEl, function() {

          // newEl.style.width = '100%';
          // newEl.style.height = '100%';
          // newEl.width = 400;
          // newEl.height = 3000;


          if (newElName.indexOf('destination') > -1){
            console.log('destino!');
            this.$.destino.appendChild(newEl);
          } else {
            this.appendChild(newEl);
          }

          this._processNewElement(newEl, top, left, newElCategoryIndex);

        }.bind(this));


      }, 

      _processNewElement: function(newEl, top, left, newElCategoryIndex) {
        var self = this;

        var cat = this.$.component_list.mainCategories[newElCategoryIndex];
        var colorClass = this._colors[newElCategoryIndex];

        newEl.id = this._generateUniqueId(newEl.tagName.toLowerCase());
        newEl.varName = this._generateVarName(newEl.id);
        newEl.className = cat;
        newEl.style.width = '100%';
        newEl.style.height = '100%';
        var elItem = {  element: newEl, 
                                      id: newEl.id,
                                      name: newEl.tagName.toLowerCase(), 
                                      top: top,
                                      left: left,
                                      category: cat,
                                      colorClass: colorClass,
                                      varName: newEl.varName
                                  };


        var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());

        // if(info.resizable || info.category==='visualize') {
        if (elItem.name.indexOf('destination') > -1) {
          console.log(elItem.name);
          elItem.resizable = false;
          setTimeout(function() {
            self.destinations.push(elItem);
          }, 200);
        } else {
          elItem.resizable = true;
        }

        self._addElementVar(elItem)


        // TO DO: make objects public

        this._initCustomMethodsObj(elItem);

        // trigger drag event

      },

      // find the ID of the event target that was clicked
      _deleteEvent: function(e) {
        var compId = e.target.getAttribute('component_id');
        if(confirm('Do you want to remove this element from the sketch?')) {
          this._deleteElement(compId);
        }
      },

      // delete element by ID
      _deleteElement: function(compId) {

        var self = this;
        var embeddedEl = self.querySelector('#'+compId);
        var elInArray = self.findElById(compId);

        // remove element from elements array (which removes it from the shadowDOM)
        var filteredEls = self._elements.filter(function(el) {
            return el.element.id!==compId;
        });
        self._elements = filteredEls;

        // remove _customMethods associated with this element
        var newCustomMethods = {};

        for (var i in self._customMethods) {
          if (i !== compId) {
            newCustomMethods[i] = self._customMethods[i];
          }
        }

        self._customMethods = newCustomMethods;

        // remove elements
        self.removeChild(embeddedEl);

        // remove var from olos object
        this[embeddedEl.varName] = null;

        //remove all connections
        self.removeAllConnectionsFromElement(compId)

        // dispose will remove this element's audio nodes and animation loops / p5 sketches / nexusUI
        embeddedEl.dispose();
      },

      removeAllConnectionsFromElement: function(elId) {

        var badConnections = this._connections.filter(function (conn, index) {
          
          //filter if element is source or target of a connection
          return (conn.source.id===elId || conn.target.id === elId);
           
        });

        var goodConnections = this._connections.filter(function (conn, index) {
          
          //filter if element is source or target of a connection
          return !(conn.source.id===elId || conn.target.id === elId)
           
        });

        this._connections = goodConnections;

        // disconnect the badConnections
        for (var i = 0 ; i < badConnections.length; i++) {
          var src = badConnections[i].source.element[badConnections[i].source.field];
          if (src instanceof AudioNode) {
            this._deleteAudioConnection(badConnections[i]);
            console.log(src);
            console.log('..is audio node');
          } else {
            console.log('removed connection ' + src + ' is not audio!!');
          }
        }

        this._drawConnections();

      },

      _deleteAudioConnection: function(connection) {
        var self = this;
        var srcElem = connection.source.element;
        var srcField = connection.source.field;
        var srcNode = srcElem[srcField];
        try{
          srcNode.disconnect();
        } catch(e) {
          self.deleteConnection(connection);
        }

        // reconnect any connections that have srcNode as the source
        for (var i = 0; i < this._connections.length; i++) {
          var conn = this._connections[i];

          if (conn.source.element === srcElem && conn.source.field === srcField) {
            var dstElem = conn.target.element;
            var dstField = conn.target.field;
            var dstNode = dstElem[dstField];
            srcNode.connect(dstNode);
          }
        }

      },


      /********************** Event Handlers Start ********************************/

      draggedOverContainer: function(e) {
        // Needed to enable droppedInContainer
        e.preventDefault();
      },

      droppedInContainer: function(e, detail, selection){
        var self = this;

        //dont know why this method is being called instead of resizedragend?!
        if(e.path && e.path.length>0 &&  e.path[0].classList.contains('resize')>0) {
          self.dragResizeEnd(e, detail, selection);

        }

        var dataTransfer = e.dataTransfer.getData('text/plain');
        // console.log(dataTransfer);
        //data added by olos-component-list //TODO make better
        if(dataTransfer && dataTransfer.length>0) {
          var dataSeg = dataTransfer.split(',');

          // dataSeg[0] is component name, dataSeg[1] is categoryIndex
          if(dataSeg.length==2) {
            self.addNewElToConnector(dataSeg, Math.round(e.offsetX/10)*10, Math.round(e.offsetY/10)*10);

            return;
          } 

        }

      },

      dragStartResize: function(e, details, selection) {
         e.stopPropagation();
      },

      dragResize: function(e, details, selection) {

          var self = this;

          var wrapper = selection.parentNode;
          //var styles = window.getComputedStyle(wrapper);
          // var wrapperTop = parseInt(styles.top.replace('px',''));
          // var wrapperLeft = parseInt(styles.left.replace('px',''));

          // var w =  e.x - wrapperLeft - 65,
          //     h = e.y - wrapperTop - 172;

          var wrapperTop = parseInt(wrapper.getBoundingClientRect().top),
              wrapperLeft = parseInt(wrapper.getBoundingClientRect().left);
          

          var w =  e.x - wrapperLeft,
              h = e.y - wrapperTop;


          // wrapper.style.width = w +'px';
          // wrapper.style.height = h +'px';

          var elementInsideId = wrapper.getAttribute('component-id');//wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);

          var element = this.findElById(elementInsideId);

          element.width = w;
          element.height = h;

          // element.shadowRoot.container.width = w;
          // element.shadowRoot.container.height = h;

          self._drawConnections();

          // RESIZE
          self.resizeEl(elementInside);
          // <-- end Resize

          e.stopPropagation();
          e.preventDefault();


        },

        dragResizeEnd: function(e, details, selection) {

          var wrapper = null, self = this;

          if(e.path && e.path.length>0 &&  e.path[0].classList.contains('resize')>0) {
            
            wrapper = e.path[0].parentNode;

          }

          var elementInsideId = wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);

          self.resizeEl(elementInside);

        },


        dragStartWrapper: function(e, details, selection) {
          console.log('Drag start wrapper: ');
          console.log(e);

          var target = e.target;
          console.log('target: ' + target);

          target.setAttribute('start-x', e.x);
          target.setAttribute('start-y', e.y);

          var dragImgEl = document.createElement('span');
          dragImgEl.setAttribute('style','opacity: 0' );
          dragImgEl.textContent = 'a';

          // add it to the document
          document.body.appendChild(dragImgEl);
          e.dataTransfer.setDragImage(dragImgEl,-200,-200);          
          
          // select this element
          var wrapperEl = selection;
          if(this._selWrapper) {
            this._selWrapper.classList.remove('selected-element');
          }
          this._selWrapper = wrapperEl;
          this._selWrapper.classList.add('selected-element');

          var elementId = wrapperEl.id;
          elementId = elementId.substring(8, elementId.length);

          // reset this._selElement
          try {
            this._selElement = this.findElById(elementId).element;
          } catch(e) {
            // set selection to destination
            this._selElement = this._elements[0];
          }

        },

        dragWrapper: function(e, details, selection) {

          if(e.path[0].classList && e.path[0].classList.length>0 && 
            (e.path[0].classList.contains('resize') || e.path[0].classList.contains('arrow'))) {
            return false;
          };

          try {
            var target = e.target; // || selection; //e.target || e.path[0];

            // for(var i = 0; i< e.path.length && !target; i++) {
            //   if(e.path[i].classList.contains('wrapper')) {
            //     target = e.path[i];
            //   }
            // }
            // console.log(target.name);

            var dx = e.x - (target.getAttribute('start-x') || 0),
                dy = e.y - (target.getAttribute('start-y') || 0);


                // keep the dragged position in the data-x/data-y attributes, add snap residue from previous drag
                var x = (parseFloat(target.getAttribute('data-x')) || 0) + dx + (parseFloat(target.getAttribute('residue-x')) || 0);
                var y = (parseFloat(target.getAttribute('data-y')) || 0) + dy + (parseFloat(target.getAttribute('residue-y')) || 0);

                sx = Math.round(x/this._snapX)*this._snapX;
                sy = Math.round(y/this._snapY)*this._snapY;

                target.setAttribute('residue-x', x - sx );
                target.setAttribute('residue-y', y - sy);


                // translate the element. 
                // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
                if(e.x!==0 ||  e.y!==0)
                {
                /*
                  target.style.webkitTransform =
                        target.style.transform = 'translate(' + sx + 'px, ' + sy + 'px)';
                */

                  var componentId = target.getAttribute('component-id');

                  this.findElById(componentId).transform = 'translate(' + sx + 'px, ' + sy + 'px)';

                  // update the position attributes
                  // 
                  target.setAttribute('data-x', sx);
                  target.setAttribute('data-y', sy);
                  

                  target.setAttribute('start-x', e.x);
                  target.setAttribute('start-y', e.y);

                  this._drawConnections();

                }
           } 
           catch(e){console.log('ERROR: ' + e)}

        }, 

        dragEndWrapper: function(e, details, selection) {
          
          
          //if resize is being dragged don't do anything (stopPropagation is not doing anything)
          // if(e.path[0].classList && e.path[0].classList.length>0 && e.path[0].classList.contains('resize')) {
          //   return false;
          // }

          var target = e.target;
          target.setAttribute('residue-x', 0 );
          target.setAttribute('residue-y', 0);

          
        }, 

        wrapperClicked: function(e, detail, selection) {
          var wrapperEl = selection;
          if(this._selWrapper) {
            this._selWrapper.classList.remove('selected-element');
          }
          this._selWrapper = wrapperEl;
          this._selWrapper.classList.add('selected-element');

          var elementId = wrapperEl.id;
          elementId = elementId.substring(8, elementId.length);

          // remove selected from this._selElement
          // if (typeof(this._selElement) !== 'undefined' && typeof(this._selElement) !== 'undefined') {
          //   this._selElement.className.replace
          //       ( /(?:^|\s)selected(?!\S)/g , '' )
          // }

          // reset this._selElement
          this._selElement = this.findElById(elementId).element;

          // if(this.$.input_table) {
          //   this.$.input_table.input = this._selElement.input;
          // }
          // if(this.$.output_table) {
          //   this.$.output_table.input = this._selElement.output;
          // }
        },

        // OUT ARROWS
        dragOutArrowStart: function(e, details, selection) {

          this.draggedEl = selection;
          //to stop wrapper drag to be called
          // e.stopPropagation();

          if(!this.svgTop || !this.svgLeft) {

            var svgRect = this.$.svg.getBoundingClientRect();
            this.svgTop = svgRect.top;
            this.svgLeft = svgRect.left;

          }


          this.startPointX = e.x - this.svgLeft;
          this.startPointY = e.y - this.svgTop;

          // create temp bezier
          this._addBezierPath( this.startPointX , this.startPointY , this.startPointX , this.startPointY , 70, 'temp_path');
          //this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70, 'temp_path');
        },

        dragOutArrow: function(e, details, selection) {
          var tempPath = this.shadowRoot.querySelector('#temp_path');

          // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
          if(e.x!==0 ||  e.y!==0)
          {

            var newPath = this._createBezierPath( this.startPointX, this.startPointY , e.x - this.svgLeft  , e.y - this.svgTop  , 70);
            tempPath.setAttribute('d',newPath);
          }               

        },

        dragOutArrowEnd: function(e, details, selection) {

          var tempPath = this.shadowRoot.querySelector('#temp_path');
          if(tempPath) {
            tempPath.parentNode.removeChild(tempPath);
          }

        },

        resizeEl: function(elementInside) {
          if(typeof elementInside.resize ==='function') {
            elementInside.resize();
          }
        },


        // IN ARROWS
        dragOverInArrow: function(e, details, selection) {
          //important! needed to allow drop
          e.preventDefault();

        },

        dragEnterInArrow: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },

        dragLeaveInArrow: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },

        mouseEnterCnx: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },

        mouseLeaveCnx: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },

        droppedOnInArrow: function(e, details, selection) {

          var self = this;

          e.target.classList.remove('drag-over');

          var className = selection.classList[0],
              targetElementId = className.substring(0, className.lastIndexOf('-') ),   
              targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),      
              source = self.findElById(self.draggedEl.classList[0]),
              target = self.findElById(targetElementId);

          // console.log(source);
          // console.log(selection);

          this._connectAttributes(source, 'output', target, targetField);

          self._drawConnections();

          e.stopPropagation();

        }, 

        // PARAMS
        dragOverParamArrow: function(e, details, selection) {
          //important! needed to allow drop
          e.preventDefault();
        },

        dragEnterParamArrow: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },

        dragLeaveParamArrow: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },

        droppedOnParamArrow: function(e, details, selection) {
          var self = this;
          e.target.classList.remove('drag-over');

          var className = selection.classList[0],
              targetElementId = className.substring(0, className.lastIndexOf('-') ),   
              targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),      
              source = self.findElById(self.draggedEl.classList[0]),
              target = self.findElById(targetElementId);

          // connect source to audioParam
          this._connectAttributes(source, 'output', target, targetField);
          // self._drawConnections();
          e.stopPropagation();
        }, 

        arrowClicked: function(e, details, selection) {
          //e.stopPropagation();

          var wrapper = null;
          var isAudioParam = false;

          for(var i = 0; i< e.path.length && !wrapper; i++) {
            if(e.path[i].classList.contains('wrapper')) {
              wrapper = e.path[i];
            }
          }

          // paramMarker is also a target
          var sourceTarget = e.path[0].classList.contains('outputMarker') ? 'source' : 'target';

          // TO DO: use this.
          if (e.path[0].classList.contains('paramMarker')) {
            isAudioParam = true;
          }

          var elementInsideId = wrapper.getAttribute('component-id');

          var connection = this._connections.filter(function(conn) {
            if(conn[sourceTarget].id===elementInsideId) {
              return true;
            }

          });


          if(connection.length>0) {

            var marker = e.path[0];
            var bezierCssPath = '#container #svg #'+connection[0].source.id+'-'+connection[0].target.id;

            var bezier = this.shadowRoot.querySelector(bezierCssPath);
            this.bezier = bezier;

            if(connection[0].highlighted) {
              connection[0].highlighted = false;

              marker.classList.remove('highlighted');
              bezier.classList.remove('highlighted');

            }
            else {

              connection[0].highlighted = true;

              marker.classList.add('highlighted');
              bezier.classList.add('highlighted');
            }
            // this.bezier = null;
          }
        },


        highlightBezier: function(bezier, connection) {
          bezier.classList.add('highlighted');
          // connection status is highlighted
        },

        deleteConnection: function(e, details, selection) {
          if (e) {
            e.stopPropagation();
          }
          var elementInsideId;

          // figure out the source
          var src;
          if (this.bezier) {
            var splitID = this.bezier.id.split('-');
            src = splitID[0]+'-'+splitID[1]+'-'+splitID[2];
            // console.log(src);
            elementInsideId = splitID[3] + '-' + splitID[4] + '-' + splitID[5];
          }
          else {
            var wrapper = null;
            for(var i = 0; i< e.path.length && !wrapper; i++) {
              if(e.path[i].classList.contains('wrapper')) {
                wrapper = e.path[i];
              }
            }
            elementInsideId = wrapper.getAttribute('component-id');
          }

          // -- or --
          // delete all connections / reconnect everything
          var srcNode, srcElem;
          for (var i = 0; i < this._connections.length; i++) {
            // console.log('orig cnx: ' + this._connections[i].target.id, elementInsideId, this._connections[i].source.id, src);

            if (this._connections[i].target.id === elementInsideId && this._connections[i].source.id === src) {
              srcNode = this._connections[i].source.field;
              srcElem = this._connections[i].source.element;
              srcElem[srcNode].disconnect();
              this._connections.splice(i,1);
            }
          }

          // if srcNode was connected to any other nodes, re-connect them
          for (var j = 0; j < this._connections.length; j++) {
            var src = this._connections[j].source;
            if (src.element === srcElem && src.field === srcNode) {
              var dstNode = this._connections[j].target.field;
              var dstElem = this._connections[j].target.element;
              try {
                srcElem[srcNode].connect(dstElem[dstNode]);
              } catch(e) {
                console.log(e);
              }
            }
          }

          // var marker = e.path[1]; 
          // console.log(marker);
          this.bezier.classList.remove('highlighted');
          this.bezier = null;

          this._drawConnections();

        },




      /********************** Event Handlers End ********************************/


        showDataBtn: function() {
            // this._showDataTable = !this._showDataTable;
            // this.$.showDataBtn.classList.toggle('active');
            // [].forEach.call(this.shadowRoot.querySelectorAll('.data-preview'), function(el) {
            //   el.style.maxHeight = el.style.maxHeight=='0px' ? '100px' : '0px';
            // });
        },







      /**
       * The functions which sets the connection (two way binding) between two element attrubutes
       * There is not really a source/target distinction in the observer since it is a two way binding (in theory)
       * but the distinction is conceptual and in UI.
       * @param  {[type]} source      Source element
       * @param  {[type]} sourceField The attribute to connect from source element
       * @param  {[type]} target      Target element
       * @param  {[type]} targetField The attribute to connect from target element
       * @return {None}             
       */
      _connectAttributes: function(source, sourceField, target, targetField) {

        var self = this;

        //find the index of connection which has the same target
        var connWithSameTargetIndex = self._connections.reduce(function(value, conn, index) {
            if (conn.target.id===target.id && conn.target.field===targetField && conn.source.id===source.id && conn.source.field === conn.sourceField) {
              return index;
            }

        }, -1);
        // and remove it from connections array
        if(connWithSameTargetIndex>-1) {
          self._connections.splice(connWithSameTargetIndex,1);
        }


        if (source === target){ //if a bubble was dropped on itself
          console.log('You cannot make a connection within the same element');
          return false;
        } else { 

          // make the connection in the elements array
          //target.inputConnectedTo = source;  // not needed
            
          var observer = new PathObserver(source.element, sourceField);  
            
          observer.open(function(newValue, oldValue) {
             target.element[targetField] = newValue;
          });

          var srcClone = {id: source.id, name: source.name, element: source.element};
          var targetClone = {id: target.id, name: target.name, element: target.element};

          targetClone.field = targetField;
          srcClone.field = sourceField;

          // make the actual connection, returns true if connection was made
          if ( this.makeConnection(source.element, sourceField, target.element, targetField) ) {
            this._connections.push({source: srcClone, target: targetClone});
          }

          return true;
        }

      },

      _drawConnections: function() {

        var self = this;


        var arrowOffsetY = 16;
        var arrowOffsetX = 0;
        var bezierCurveX = 45;  // the larger the value the smoother the curve


        //clear all paths. since it is not done often it is fine to do it in a not optimized way
        self.$.svg.innerHTML = '';

        for (var i = 0; i < self._connections.length; i++) {


          var conn = self._connections[i];

          var srcEl = conn.source.element || self.querySelector('#'+conn.source.id); //TODO do this in initialization method
          var targetEl = conn.target.element || self.querySelector('#'+conn.target.id);

          // isAudioParam determines offset of the connection target
          var isAudioParam = conn.target.field.indexOf('Param') > -1 ? true : false;

          var srcWrapper = self.shadowRoot.querySelector('#wrapper-'+srcEl.id);
          var targetWrapper = self.shadowRoot.querySelector('#wrapper-'+targetEl.id);

          // var srcRect = srcEl.getBoundingClientRect();
          // var targetRect = targetEl.getBoundingClientRect();

          var srcRect = srcWrapper.getBoundingClientRect();
          var targetRect = targetWrapper.getBoundingClientRect();

          var svgRect = self.$.svg.getBoundingClientRect();

          //
          var paramOffset = (conn.target.field.indexOf('Param') > -1) ? [0, targetRect.height - 25] : [0,0];

          var startX = srcRect.right - svgRect.left + arrowOffsetX; //srcRect.left + srcRect.width + 30 - containerOffsetX;
          var startY = srcRect.top - svgRect.top + arrowOffsetY;
          var endX = targetRect.left  - svgRect.left - arrowOffsetX + paramOffset[0];
          var endY = targetRect.top  - svgRect.top + arrowOffsetY + paramOffset[1];


          self._addBezierPath(startX, startY, endX, endY , bezierCurveX, srcEl.id + '-' + targetEl.id, conn.highlighted, isAudioParam);
          
        }

      },


      /**
       * Sacffold a new th-connector from state data. Usage: 
       *  var newConnector = document.createElement('th-connector');
       *  newConnector.scaffoldFromData(elements, connections)
       *  where elements and connections are parsed json files coming form dumpStateDataAsString
       * @param  {Object} elements    elements state data
       * @param  {Object} connections connections
       * @return {None}             
       */
      
      scaffoldFromData: function(elements, connections) {

        //this._elements = elements;

         elements.forEach(function(el) {
            var alreadyExist = this.querySelector('#'+el.id);
            if(!alreadyExist) {
              var domEl =  document.createElement(el.name);

              this.$.component_list.checkAndImport(domEl, function() {

                domEl.style.width = '100%';
                domEl.style.height = '100%';

                domEl.id = el.id;
                
                if(el.name==='th-table-data') {
                  domEl.output = el.output;
                }
                else {
                  Object.keys(domEl.publish).forEach(function(attr) {


                    if(attr!=='input' && attr!=='output' && el[attr]) {
                      domEl[attr] = el[attr]; 
                    }

                  });
                }
                this.appendChild(domEl);
                //this._elements.push(el);

             }.bind(this));

            }

          }.bind(this));

         //delay to make sure position of elements are final
         setTimeout(function() {

          this.setConnections(connections);         

         }.bind(this),500);


        //newConnector._drawConnections()

      },

      setConnections: function(connections) {
        this._connections = connections;


        this._connections.forEach(function(connection) {
          if(!connection.source.element) {
            connection.source.element = this.querySelector('#'+connection.source.id);
          }
          if(!connection.target.element) {
            connection.target.element = this.querySelector('#'+connection.target.id);
          }
          this._connectAttributes(connection.source, 'output', connection.target, 'input');
        }.bind(this));

        this._drawConnections();
      },      

      dumpStateDataAsString: function() {
        var self = this;

        var toDumpEls = _.map(this._elements, function(el) {
          var domObject = el.element;
          var cloned = _.clone(el);  
          Object.keys(domObject.publish).forEach(function(attr) {

            //ignore input attribute and output (except where the component is th-table-data)
            if(attr==='chartData' || attr==='input' || (attr==='output' && el.name!=='th-table-data')) {
              return;
            }
           
            cloned[attr] = domObject[attr];


          });
          return cloned;

        });

        var retObj = {elements: toDumpEls, connections: this._connections};

        var ret = JSON.stringify(retObj, this.removeDomObjects);

        //var connectionsJSON = JSON.stringify(this._connections , this.removeDomObjects);

         

        return ret;

      }, 


      removeDomObjects: function(key, value) {


          if(value instanceof HTMLElement) 
            return undefined;
          else
            return value;

      },              


      findElById: function(id){

        var self = this;
        element = self._elements.filter(function(el){
          return el.id === id;
        })[0];

        return element;
      },



      /**
       * Checks if a componenet has input attributes (any attribute which is named input*)
       * @param  {Object} published Object containing all published attributes
       * @return {Object}           list of attributes that are input.
       */
      _checkForInputAttr: function(published){
        console.log(published);
        if(!published) {
          return false;
        }
        var attrs = Object.keys(published).filter(function(item) {
          return item.indexOf("input") > -1;

        });
        console.log(attrs);
        return attrs;
      },
     
      /**
       * Checks if a component has output attributes.
       * @param  {Object} published Object containing all published attributes
       * @return {boolean}       True if component has output attribute (only one)
       */
      _checkForOutputAttr: function(published){
        if(!published) {
          return false;
        }

        return Object.keys(published).indexOf("output") > -1 ? true : false;
      },

      /**
       *  Checks if a component has audioParams. AudioParams must have 'param'
       *  in the name and be published attributes.
       *  
       *  @param  {Object} published Object containing all published attributes
       *  @return  {Oobject} list of attributes that are audioParams.
       */
      _checkForAudioParams: function(published) {
        if(!published) {
          return false;
        }
        var attrs = Object.keys(published).filter(function(item) {
          return item.toLowerCase().indexOf("param") > -1;
        });
        console.log(attrs);
        return attrs;
        // console.log(published.audioParams);
        // return published.audioParams;

        // var audioParams = [];
        // var audioParamKeys = keys.filter(function(key){return newEl.audioParams; });
        // console.log('hi');
        // for (var j in audioParamKeys) {
        //   var audioNode = newEl[audioParamKeys[j]];
        //   for (var i in audioNode) {
        //     if (audioNode[i] instanceof AudioParam) {
        //       audioParams.push(audioNode[i]);
        //     }
        //   }
        // }
        // console.log(audioParams);
        // return audioParams;
      },

      /**
       * Generates unique ids for components
       * @param  {String} elName Component name
       * @return {[type]}        Unique component id
       */
      _generateUniqueId: function(elName){
          var self = this;
          var num = 0;

          var tagsWithSameName = self._elements.filter(function(elem){return elem.name == elName});
          
          if(tagsWithSameName){
            num+= tagsWithSameName.length;
          } 
          
          var uniqueId = elName + '-' + num;
          
          return uniqueId;
      }, 

      // convert from an input like olos-element-name-0 to "elementName0"
      _generateVarName: function(elId) {
        // remove split at '-' and remove 'olos' first item from array
        var arr = elId.split('-').slice(1);
        var varName = '';

        varName = arr[0];

        // if varName has additioal stuff, like sound-file, return soundFile
        for (var i = 1; i < arr.length; i++ ) {
          var capString = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
          varName += capString;
        }

        return varName;
      },

      // store element variable name, and include it in olos.elements Array
      _addElementVar: function(elItem) {
        this._elements.push(elItem);

        olos[elItem.varName] = elItem.element;
      },

      // set element variable name to null, and remove it from olos.elements Array
      _removeElementVar: function(elItem) {

      },

      _createBezierPath: function(startX, startY, endX, endY, handleOffsetX) {

          // make handleOffsetX larger when source element is on the right side of target
          if(startX > endX) {
            handleOffsetX *= 2;
          }
          var distance = Math.sqrt(Math.pow(endX-startX, 2) + Math.pow(endY-startY,2));
          // decrease handleOffsetX when too close...
          if(distance<100) {
             handleOffsetX /= 2;
          }
          if(distance<50) {
             handleOffsetX /= 4;
          }
          var path = "M"+parseInt(startX)+","+parseInt(startY)+
                     " C"+parseInt(startX + handleOffsetX)+","+parseInt(startY)+
                     " "+parseInt(endX - handleOffsetX)+","+parseInt(endY)+
                     " "+parseInt(endX)+","+parseInt(endY);
          return path;
      },

      _addBezierPath: function(startX, startY, endX, endY, handleOffsetX, id, highlighted, isParam) {

          var aLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
          var path = this._createBezierPath(startX, startY, endX, endY, handleOffsetX);

          aLine.setAttributeNS(null, 'd',path);
          aLine.setAttributeNS(null, 'stroke', '#555');// conn.source.color);
          aLine.setAttributeNS(null, 'stroke-width', '5');
          aLine.setAttributeNS(null, 'fill-opacity', '0');
          aLine.setAttribute('class', 'cnxn');

          if(id) {
            aLine.setAttributeNS(null, 'id', id);
          }

          if(highlighted) {
            aLine.classList.add('highlighted');
          }
          
          if(isParam) {
            aLine.classList.add('param');
          }

          _dragObj.connectorShape = aLine;
          this.$.svg.insertBefore(aLine, this.$.svg.firstChild);

      },

      //// olos environment

      makeConnection: function(src, srcPort, dst, dstPort, svgPath) {

        var isAudioParam = dstPort.indexOf('Param') > -1 ? true : false;
        var connectorShape = {};

        if (_dragObj && _dragObj.connectorShape) {
          connectorShape = _dragObj.connectorShape;
        }

        // Put an entry into the source's outputs
        if (!src.outputConnections)
            src.outputConnections = new Array();
        var connector = new Object();
        connector.line = connectorShape;
        connector.source = src;
        connector.destination = dst;
        connector.sourcePort = src[srcPort];
        connector.destinationPort = dst[dstPort];
        connector.destinationLabel = dstPort;
        src.outputConnections.push(connector);

        // Put an entry into the destinations's inputs
        if (!dst.inputConnections){
          dst.inputConnections = new Array();
        }
        connector = new Object();
        connector.line = connectorShape;
        connector.source = src;
        connector.destination = dst;
        connector.sourcePort = src[srcPort];
        connector.destinationPort = dst[dstPort];
        connector.destinationLabel = dstPort;
        dst.inputConnections.push(connector);

        connectorShape.inputConnection = connector;
        connectorShape.destination = dst;

        // make path clickable
        // connectorShape.addEventListener('onclick',clickedOnConnection);

        connectorShape = null;
        // save connections to component source and destination
        if (src[srcPort] instanceof AudioNode && dst[dstPort] instanceof AudioNode) {
          src[srcPort].connect(dst[dstPort]);
        } else if (dst[dstPort] instanceof AudioParam) {
          console.log('audio param connection!');
          src[srcPort].connect(dst[dstPort]);
        } else if (dst[dstPort] instanceof Array) { // otherwise it is data
          console.log(dst[dstPort]);
          console.log('add to destination array');
          // add to input array
          dst[dstPort].push(src[srcPort]);
        } else if (src[srcPort] instanceof AudioNode) {
          try {
            console.log('connect audio param to script processor');
            var scriptProcessor = audioContext.createScriptProcessor();
            src[srcPort].connect(scriptProcessor);
            dst[dstPort] = scriptProcessor;
          } catch(e) {
            console.log(e);
            return false;
          }
        }
        else {
          console.log(src[srcPort]);
          console.log('could not make a connection');
          return false;
        }

        return true;
      },

        // called by connectorShape object, this = the instance of that object when it deletes itself.
      clickedOnConnection: function(e) {
        // this.bezier = the most recently clicked on connection
        this.bezier = this.shadowRoot.querySelector('#'+e.toElement.id);

        // if this bezier is already highlighted, delete the connection represented by this bezier
        if (String(this.bezier.classList).indexOf('highlight') > -1 ) {
          // console.log('delete');
          this.deleteConnection(e);
        } else {
          // if not highlighted, then highlight
          this.highlightBezier(this.bezier);
        }

        // var connections = this.destination.inputConnections;
        // breakSingleInputConnection( connections, connections.indexOf( this.inputConnection ) );

      },

      // clickInContainer helps detect if a bezier was clicked
      clickInContainer: function(e) {
        var className = e.toElement.className;
        if ( className.baseVal && className.baseVal.indexOf('cnxn') > -1 ) {
          this.clickedOnConnection(e);
        }
      },

      // list public methods in dropdown
      _listPublicMethods: function(el) {
        // var codeEditor = this.$.codeeditor;

        // find this element's public methods
        var publicMethods = el.publicMethods;

        // TO DO: showpublicmethodsinavenue
        if (typeof(publicMethods) !== 'undefined') {
          for (var i = 0; i < publicMethods.length; i++) {

          }
        }
      },

      // show code in the codeEditor
      _showCode: function(el) {
        var self = this;
        var codeEditor = this.$.codeeditor;

        // find this element's public methods
        var publicMethods = el.publicMethods;

        // this._setupMethodDropdown(publicMethods);

        // for now, just show the first editable method
        // var methodIndex = 0;

        // show code TO DO: make multiple parts editable
        // var displayCode = String(el.publicAudio);

        if (typeof(publicMethods) !== 'undefined' && publicMethods.length > 0) {
          // var methodName = publicMethods[methodIndex];
          var methodName = this._selectedMethod;
          var displayCode;

          // if we have already set a custom value for this method, display that
          if (typeof (this._customMethods[el.id][methodName]) !== 'undefined'){
            displayCode = this._customMethods[el.id][methodName];
            console.log('the code already exists! and is...' );
          } else {
            displayCode = String(el[methodName]);
            // remove first and last lines of the function to only show its contents
            displayCode = displayCode.split('\n');
            displayCode.shift();
            displayCode.pop();

            // remove indentation so it looks nice
            displayCode.forEach(function(row, index){
              if (row[0] === '\t') {
                console.log('it is a tab');
                // remove the tab
                row = row.substr(1);
              } else if (row[0] === ' ' && row[1] === ' '){
                // remove the space
                row = row.substr(6);
              }
              displayCode[index] = row;
            });

            displayCode = displayCode.join('\n');
          }

          codeEditor.setValue(displayCode);

          // tell codeEditor to update the method when code is changed
          codeEditor.methodName = methodName;
          codeEditor.currentMethod = el['methodName'];

          codeEditor.mirror.on('change', function(e) {
            self.updateCode(e);
          });

          this.updateCode();

        }
        else {
          codeEditor.setValue('//selected element has no public methods');
          // this.$.methodDropdown.$.label.innerHTML = 'No Method Selected';
          // console.log(this.$.methodDropdown);
          // this.$.methodDropdown.label = 'No Method Selected';

          codeEditor.mirror.on('change', function(e) {

          });
        }

      },

      updateCode: function(x) {
        var codeEditor = this.$.codeeditor;
        var methodName = this._selectedMethod;
        var currentMethod = codeEditor.currentMethod;
        // if there are no errors,

        // set currentMethod
        var newCode = codeEditor.getValue();
        var elMethod = this._selElement[methodName];
        // console.log(this);
        this._selElement[methodName] = Function(newCode).bind(this._selElement);
        this._selElement[methodName]();

        this._saveCustomMethod(this._selElement, methodName, newCode );
      },

      // SAVE CUSTOM METHODS

      _initCustomMethodsObj: function(elItem) {
        this._customMethods[elItem.id] = {};
      },

      _saveCustomMethod: function(element, methodName, code) {
        this._customMethods[element.id][methodName] = code;

        // TO DO - ensure that when elements are overwritten,
        // customMethods related to that element are deleted
      },

      _setupMethodDropdown: function(el) {
        var publicMethods = el.publicMethods;
        this._publicMethods = publicMethods;
        if (typeof(this._publicMethods) !== 'undefined' && this._publicMethods.length > 0) {
          this._selectedMethod = this._publicMethods[0];
        }
      },

      // OBSERVER for selected element changed
      _selElementChanged: function() {

        // TO DO: if 'undefined' show global methods
        if (this._selElement === undefined) {
          // this._selElement = this;
          return;
        }

        // TO DO: figure out why this doesnt show as default
        this._selectedMethod = 'No Method Selected';
        this._setupMethodDropdown(this._selElement);
        this._listPublicMethods(this._selElement);
        this._showCode(this._selElement);

        // TO DO: bring back code here
        // this._methodChanged();

        // remove 'selected' class from other elements, add 'selected' class to this
        // this._selElement.className = this._selElement.className + ' selected';

        this._updateDocs(this._selElement);
      },

      _updateDocs: function(element) {
        var pathToHTML = '../' + element.name +'/'+ element.name + '.html';
        this.$.docViewer.url = pathToHTML;
      },

      _methodChanged: function(e, detail) {
        var self = this;
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        this._selectedMethod = detail.item.getAttribute('label');
        console.log(this._selectedMethod);
        this._showCode(this._selElement);
      },

      // called when the tab to view this element's code is clicked
      _elCodeButtonClicked: function(e) {
        this.$.codeDialog.toggle()
      },

      _elInfoButtonClicked: function(e) {
        this.$.infoDialog.toggle()
      },

      _mouseLeaveOutput: function(e) {
        // e.path[0].
        console.log('leave');
      },

      _mouseEnterOutput: function(e) {
        console.log('enter');
      },

      // KEY EVENTS
      keydownHandler: function(e) {
        this.keypressHandler(e);
      },

      keypressHandler: function(e) {
        var self = this;
        var focusedArea = e.path['0'].localName;

        // make sure it is not a text or input area
        if ( focusedArea.indexOf('text') > -1 || focusedArea.indexOf('input') > -1) {
          console.log('in a text area');
          return;
        }

        switch(e.which) {
          // if deleteKey:
          case(8):
            e.preventDefault();
            e.stopPropagation();
            // if bezier was selected, delete that. Otherwise, delete element
            if (self.bezier) {
              self.deleteConnection();
            } else {
              self._deleteElement(self._selElement.id);
            }
            break;
          case(18):
            console.log('option key');
          default:
            break;
        } 
      },


    // SAVE AND LOAD SESSIONS
    _environmentSave: function() {
      var olosData = {
        "elements" : this._elements,
        "connections": this._connections
      }
      console.log(olosData);
    },

    _environmentLoad: function() {

    },

    _environmentClear: function() {
      var j;

      if(confirm('Are you sure you want to clear your entire sketch?')) {
        // dispose of every element
        for (var j = this._elements.length -1 ; j > 0 ; j--) {
          if (j === 0) {
            return
          }
          console.log(this._elements[j].id);
          this._deleteElement(this._elements[j].id);
        }

        // delete any remaining connections
        for (j = this._connections.length -1 ; j > 0 ; j--) {
          this._deleteAudioConnection(this._connections[i]);
        }

        // re-initialize variables:
        this._selElement = undefined;
        this.bezier = undefined;
        this.connections = [];
      }
    },

    _connectionsChanged: function() {
      console.log('connections changed');
      this._drawConnections();
    }

    });
  </script>
</polymer-element>
