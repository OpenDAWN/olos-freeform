<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-splitter/core-splitter.html">

<!-- used to show multiple methods in code-editor -->
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-dropdown/paper-dropdown.html">
<link rel="import" href="../paper-item/paper-item.html">

<link rel="import" href="../olos-component-list/olos-component-list.html">
<link rel="import" href="../olos-code-editor/olos-code-editor.html">

<link rel="import" href="../olos-piano/olos-piano.html">
<link rel="import" href="../olos-clock/olos-clock.html">


<link rel="import" href="../olos-doc-viewer/olos-doc-viewer.html">

<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../core-tooltip/core-tooltip.html">
<link rel="import" href="../paper-toggle-button/paper-toggle-button.html">


<link rel="stylesheet" href="colors.css">

<polymer-element name="olos-freeform" attributes="" on-keydown="{{keydownHandler}}" on-keypress="{{keypressHandler}}">
  <template>
    <link rel="stylesheet" href="olos-freeform.css">
    <link rel="stylesheet" href="colors.css">

    <div id="zoomOptions">
      <core-icon-button id="zoomInBtn" class="" icon="add" on-click="{{zoomIn}}">
      </core-icon-button>
      <br/>
      <input is="core-input" id="zoomRange" type="range" value="{{_zoom}}" min="{{_zoomMin}}" max="{{_zoomMax}}" step="{{_zoomStep}}" style="width:25px" list=zoomsettings>
      </input>
      <datalist id="zoomsettings">
        <option>1</option>
        <option>0.8</option>
        <option>0.6</option>
      </datalist>
      <br/>
      <core-icon-button id="zoomOutBtn" icon="remove" on-click="{{zoomOut}}">
      </core-icon-button>
    </div>

    <!-- header -->
    <core-toolbar id="toolbar" class="small">
      <h1>((( OLoS )))</h1>
      <paper-input-decorator label="Enter a name to save">
       <input id="filename" is="core-input">
       </paper-input-decorator>

<!--       <paper-icon-button id="new"
        icon="autorenew"></paper-icon-button>
      <paper-icon-button id="undo"
        icon="undo"></paper-icon-button>
      <paper-icon-button id="redo"
        icon="redo"></paper-icon-button>
 -->
      <paper-icon-button id="save"
        icon="save" on-click="{{saveToLocalStorage}}"></paper-icon-button>

      <paper-dropdown-menu id="loadDropdown" label="Saved Files">

<!--         <paper-icon-button id="open"
          icon="folder"></paper-icon-button>
 -->
        <paper-dropdown class="dropdown" label="Saved Files">
          <core-menu selected="" id="fileLoader" on-core-select="{{_loadSavedFile}}" class="menu" icon="settings">
            <template repeat="{{savedFile, index in _examples}}">
              <paper-item name="{{savedFile}}" label="{{savedFile}}">{{savedFile}}</paper-item>
            </template>
          </core-menu>
        </paper-dropdown>
      </paper-dropdown-menu>


      <!-- <paper-dropdown-menu id="exampleDropdown" label="Examples"> -->

          <!-- <paper-icon-button id="morebutton" icon="more-vert"></paper-icon-button> -->

        <paper-dropdown class="dropdown" >
          <core-menu selected="" id="exampleLoader" on-core-select="" class="menu">
            <template repeat="{{savedFile, index in _examples}}">
              <paper-item label="{{savedFile}}">{{savedFile}}</paper-item>
            </template>
          </core-menu>
        </paper-dropdown>
      </paper-dropdown-menu>

      <core-tooltip label="Export Code" position="bottom center">
        <paper-icon-button id="exportCode" icon="language" on-click="{{_saveAsCode}}"></paper-icon-button>
      </core-tooltip>

      <core-tooltip label="Info/Help" position="bottom center">
        <paper-icon-button id="info"
          icon="info-outline"></paper-icon-button>
      </core-tooltip>

      <core-tooltip label="Clear" position="bottom center">
        <paper-icon-button id="clear"
          icon="clear" on-click={{_environmentClear}}></paper-icon-button>
      </core-tooltip>

      <olos-clock id="clock"></olos-clock>
      <olos-piano id="piano"></olos-piano>

    </core-toolbar>


    <core-icon-button id="showGlobalBtn" class="active" icon="sort" on-click="{{showGlobalBtn}}" alt="show component data">
      <span>global code</span>
    </core-icon-button>

    <!-- code dialog -->
      <paper-dialog  class="modalDialog" id="codeDialog" sizingtransition="core-transition-center" heading="var {{_selElement.varName}}">

          <core-tooltip label="auto-update: {{_autoUpdateCode}}">
            <paper-toggle-button checked on-change="{{toggleAutoUpdateCode}}"></paper-toggle-button>
          </core-tooltip>

          <core-tooltip label="opacity">
            <input is="core-input" id="opacitySlider" committedValue="{{codeOpacity}}" value="{{codeOpacity}}" min="0.2" max="1.0" step="0.01" type="range" style="width:40px"></input>
          </core-tooltip>

          <div id="dialogWrapper">
            <label>Current Method: </label>
            <paper-dropdown-menu id="methodDropdown" label="{{_selectedMethod}}">
              <paper-dropdown class="dropdown">
                <core-menu selected="0" id="selector" on-core-select="{{_methodChanged}}" class="menu">
                  <template repeat="{{meth, index in _publicMethods}}">
                    <paper-item label="{{meth}}">{{meth}}</paper-item>
                  </template>
                </core-menu>
              </paper-dropdown>
            </paper-dropdown-menu>
          <olos-code-editor id="codeeditor" style="width:100%; height:100%"></olos-code-editor>
        </div>
    </paper-dialog>

    <!-- global dialog -->
<!--     <paper-dialog class="modalDialog" id="globalDialog" sizingTarget="window" autoCloseDisabled transition="core-transition-center" heading="Global Code">

      <core-tooltip label="opacity">
        <input is="core-input" committedValue="{{globalCodeOpacity}}" value="{{globalCodeOpacity}}" min="0.3" max="1.0" step="0.01" type="range" style="width:40px"></input>
      </core-tooltip>

      <olos-code-editor id="globalEditor"></olos-code-editor>

    </paper-dialog> -->

    <!-- info dialog -->
    <paper-dialog id="infoDialog" backdrop transition="core-transition-center" heading="var {{_selElement.varName}}">
      <!-- <olos-doc-viewer flex style=" position:fixed; right:0px; top: 400px; width:350px; height:600px; background-color:#fdffdf" id="docViewer"> -->

      <olos-doc-viewer flex style="width:720px; height:600px; background-color:#fdffdf" id="docViewer">

      </olos-doc-viewer>
    </paper-dialog>


      <label class="component-list-label">Drag components into canvas:</label>
      <olos-component-list id="component_list"></olos-component-list>

      <div class="destBar" vertical layout>
        <div id="destino" width="300" height="30">
          <!-- destination -->
          <template repeat="{{destination in destinations}}">
            <div class="wrapper" id="wrapper" draggable="false">
            <div class="wrapper {{destination.name}} {{destination.colorClass + '2'}}" id="wrapper-{{destination.element.id}}" component-id="{{destination.element.id}}" on-click="{{wrapperClicked}}" style="top: {{destination.top}}px; left: {{destination.left}}px; transform: {{destination.transform}}; width: {{destination.width}}px; height: {{destination.height}}px" on-click="{{wrapperClicked}}" on-dragStart="{{dragStartWrapper}}" on-drag="{{dragWrapper}}" on-dragend="{{dragEndWrapper}}" draggable="false"><!-- on-drop="{{droppedOnInArrow}}" needed? -->

              <!-- Input -->
              <div class="connectors-in">
                <ul>
                  <template repeat="{{ins in destination.element.publish | _checkForInputAttr}}">
                    <li class="{{destination.element.id}}-{{ins}} arrow in-arrow" on-dragover="{{dragOverInArrow}}" 
                    on-drop="{{droppedOnInArrow}}" on-dragenter="{{dragEnterInArrow}}" on-dragleave="{{dragLeaveInArrow}}" on-mouseenter="{{dragEnterInArrow}}" on-mouseleave="{{dragLeaveInArrow}}" on-click="{{arrowClicked}}">
                      <svg class="inputMarkerSVG" style="opacity:0.5; top:-50px; left:-40px;border-top: 80px solid #ffff00;
                      border-bottom: 80px solid #ffff00;
                      border-left: 100px solid #ffff00; pointer-events:all; z-index:105" viewBox="0 0 0 0">
                        <ellipse cx="-100" cy="0" rx="50" ry="50"></ellipse>
                        <div class="delete" on-click="{{deleteConnection}}">x</div>
                      </svg>
                    <span class="drop-zone tooltip">{{ins}}
                    </span>
                    </li>
                  </template>
                </ul>
              </div>
            </div>
          </template>
        </div>
      </div> <!-- end dest bar -->


    <div id="container" on-mousedown="{{clickInContainer}}" on-drop="{{droppedInContainer}}" on-dragover="{{draggedOverContainer}}" on-mouseup="{{dragEndSVG}}" on-mousemove="{{dragSVG}}">

      <svg id="svg"></svg>

      <!-- Components and connector dots --> 
      <!--<template if="{{_positioned}}">-->


        <template repeat="{{el, index in _elements }}">
          <template if="{{el.id | noDest}}">

            <div class="wrapper {{el.name}} {{el.colorClass + '2'}}" id="wrapper-{{el.element.id}}" component-id="{{el.element.id}}" on-click="{{wrapperClicked}}" 
            style="top: {{el.top}}px; left: {{el.left}}px; transform: {{el.transform}}; width: {{el.width}}px; height: {{el.height}}px;" 
            on-click="{{wrapperClicked}}" on-dragStart="{{dragStartWrapper}}" on-drag="{{dragWrapper}}" on-dragend="{{dragEndWrapper}}" draggable="true"><!-- on-drop="{{droppedOnInArrow}}" needed? -->

            <div>
                <label class="{{el.colorClass + '3'}} labelTab" width="100%">
                  <core-tooltip label="Variable Name">
                    olos.{{el.varName}}
                  </core-tooltip>
                </label>
            </div>

            <div class="{{el.colorClass + '4'}} codeTab" height="100%" width="30%" on-click="{{_elCodeButtonClicked}}">
              <core-tooltip label="Edit Source Code" position="top" class="fancy">
                &lt &#92; &gt
              </core-tooltip>
            </div>

            <div  class="elInfo {{el.colorClass + '5'}}" component_id="{{el.element.id}}" on-click="{{_elInfoButtonClicked}}">
              <core-tooltip label="Documentation" position="top">
                ( i )
              </core-tooltip>
            </div>

            <div  class="deleteEl {{el.colorClass + '4'}}" component_id="{{el.element.id}}" on-click="{{_deleteEvent}}">
              <core-tooltip label="Delete" position="top">
                X
              </core-tooltip>
            </div>

            <!-- Input -->
            <div class="connectors-in" >
              <template repeat="{{ins in el.element.publish | _checkForInputAttr}}">
                <ul>
                    <li class="{{el.element.id}}-{{ins}} arrow in-arrow" on-dragover="{{dragOverInArrow}}" 
                    on-drop="{{droppedOnInArrow}}" on-dragenter="{{dragEnterInArrow}}" on-dragleave="{{dragLeaveInArrow}}" on-mouseenter="{{dragEnterInArrow}}" on-mouseleave="{{dragLeaveInArrow}}" on-click="{{arrowClicked}}">
                      <svg class="inputMarkerSVG" viewBox="-20 0 20 20">
                        <!-- <ellipse cx="-15" cy="10" rx="5" ry="5"></ellipse> -->
                        <circle cx="-5" cy="10" r="4" />
                        <circle cx="-5" cy="10" r="11" stroke="black" stroke-width="4" fill="none" />

                      </svg>
                      <div class="delete" on-click="{{deleteConnection}}">x</div>
                    <span class="drop-zone tooltip">{{ins}}
                    </span>

                      <!--{{ins}}-->
                    </li>
                </ul>
              </template>
            </div>

            <!-- audioParams -->
            <div class="connectors-params">
              <template repeat="{{params in el.element.publish | _checkForAudioParams}}">
                <ul>
                  <li class="{{el.element.id}}-{{params}} arrow param-arrow" on-dragover="{{dragOverParamArrow}}" 
                  on-drop="{{droppedOnParamArrow}}" on-dragenter="{{dragEnterParamArrow}}" on-dragleave="{{dragLeaveParamArrow}}" on-mouseenter="{{dragEnterParamArrow}}" on-mouseleave="{{dragLeaveParamArrow}}" on-click="{{arrowClicked}}">
                    <!-- <div class="paramMarker"> -->
                      <svg class="paramMarkerSVG" viewBox="-20 0 20 20">
                        <circle cx="-10" cy="10" r="3" />
                        <circle cx="-10" cy="10" r="5.5" stroke="black" stroke-width="1" fill="none" />
                      </svg>
                      <div class="delete" on-click="{{deleteConnection}}">x</div>
                      <span class="drop-zone">{{params}}</span>

                    <!-- </div> -->
                  </li>
                </ul>
              </template>
            </div>

            <content select="#{{el.id}}"></content>

            <!-- Output -->
            <div class="connectors-out" >
              <template if="{{el.element.publish | _checkForOutputAttr}}">
                <div id="{{index}}"  class="{{el.element.id}} arrow out-arrow" 
                  on-drag="{{dragOutArrow}}" on-dragstart="{{dragOutArrowStart}}" on-dragend="{{dragOutArrowEnd}}"  
                   on-click="{{arrowClicked}}" draggable="true" style="z-index:100" >

                    <svg class="outputMarker" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                       viewBox="0 0 20 20">
                      <circle cx="8" cy="10" r="8" />
                      <circle cx="6" cy="10" r="10" stroke="black" stroke-width="1.5" fill="none" />
                      </svg>
                      <!-- <core-icon id="marker" icon="radio-button-on"></core-icon> -->
              </template>
            </div>

            <template if="{{el.resizable}}">
              <div class="resize" draggable="true" on-dragStart="{{dragStartResize}}" on-drag="{{dragResize}}" on-dragend="{{dragEndResize}}"></div>
            </template>
          
          </div>
          </template>

        </template>

    </div> <!-- end container-->

  </template>

  <script type="text/javascript" src="../p5js/lib/p5.js"></script>
  <script type="text/javascript" src="../p5js/lib/addons/p5.sound.js"></script>
  <script type="text/javascript" src="../Tone/build/Tone.js" defer></script>
  <script type="text/javascript" src="../lodash.js/lodash.min.js"></script>

  <script type="text/javascript" src="../nexusUI/dist/nexusUI.js"></script>

  <!-- sockets -->
  <script type="text/javascript" src="../socket.io-client/socket.io.js"></script>

  <script>
    var socket = io.connect('localhost:8080/');
  </script>



  <script>

    PolymerExpressions.prototype.noDest = function(str) {
      var i = str.indexOf('destination') > -1 ? true : false;
      if (!i){
        return str;
      }
    };

    // set up global p5
    function setup() {
      noLoop();
      noCanvas();
    }

    // GLOBAL
    if (window.p5 && window.p5.soundOut) {
      var audioContext = p5.prototype.getAudioContext();
    } else {
      // TO DO: add shims
      audioContext = new AudioContext();
    }

    // nx.colorize('fill', '#C0C0C0');
    nx.colorize('fill', 'rgb(110, 103, 100)');
    // nx.colorize('fill', 'rgb(155, 155, 155)');
    nx.colorize('accent', '#00FFFF');
    nx.colorize('border', '#CEDE99');
    // nx.colorize('border', 'rgb(255, 220, 157)');
    // nx.colorize('border', '#9370DB');
    // nx.colorize('border', 'palegoldenrod');


    nx.colorize('accentborder', '#fff000');

    var _dragObj = {};

    Polymer({

      destinations: [],

      _elements: [],
      _connections: [],

      _selElement: undefined,
      _highlightedConnection: null,
      _selectedMethod: null,
      _publicMethods: null,

      // this item has public methods
      publicMethods: ['globalCode', 'globalScale', 'globalClock'],
      
      // debounce update, in seconds
      _codeUpdateFrequency: 2,
      _lastCodeUpdate: 0,
      _autoUpdateCode: true,

      _snapX: 10,
      _snapY: 10,
      _showGlobalCode: false,

      _zoom: 1,
      _zoomMax: 1,
      _zoomMin: 0.4,
      _zoomStep: 0.2,

      // store all of the methods that have been overwritten
      // id: methodName: code
      _customMethods: {},

      _examples: [],

      // color scheme
      _colors: ['a', 'b', 'c', 'd'],

      codeOpacity: 0.9,
      // globalCodeOpacity: 0.7,

      clock: null,
      piano: null,

      domReady: function() {
        var self = this;

        this.addEventListener('core-resize', function() {
          this._drawConnections();
        });

        this.addNewElToConnector('olos-destination', '-1', 0, 0);

        // set initial modal opacity
        this.codeOpacityChanged();

        this.id = 'olos';
        this.varName = 'olos';
        // init custom methods object for the environment
        this._initCustomMethodsObj(this);

        this.clock = this.$.clock;
        this.piano = this.$.piano;

        this._examples = Object.keys(window.localStorage);

        this.$.zoomRange.value = this._zoom;

        window.addEventListener('scroll', function() {
          self._scrollHandler();
        });

      },

      ready: function() {
        // this.focus();
        this.tabIndex = 0;

        // assign olos variable to window
        window.olos = this;

        // start animation loop
        this.animate();
      },

      // helpful?
      reFresh: function() {
        this._elements = [];
        this._connections = [];
        this._selElement = undefined;
        this._highlightedConnection = null;
        this._selectedMethod = null;
        this._publicMethods =  null;
      },

      addNewElToConnector: function(newElName, newElCategoryIndex, left, top){

        var newEl = document.createElement(newElName);
        newEl.name = newElName;

        this.$.component_list.checkAndImport(newEl, function() {

          // newEl.style.width = '100%';
          // newEl.style.height = '100%';
          // newEl.width = 400;
          // newEl.height = 3000;


          if (newElName.indexOf('destination') > -1){
            this.$.destino.appendChild(newEl);
          } else {
            this.appendChild(newEl);
          }

          return this._processNewElement(newEl, top/this._zoom, left/this._zoom, newElCategoryIndex);

        }.bind(this));

      },

      _processNewElement: function(newEl, top, left, newElCategoryIndex) {
        var self = this;

        var cat = this.$.component_list.mainCategories[newElCategoryIndex];
        var colorClass = this._colors[newElCategoryIndex];

        newEl.id = this._generateUniqueId(newEl.tagName.toLowerCase());
        newEl.varName = this._generateVarName(newEl.id);
        newEl.className = cat;
        newEl.style.width = '100%';
        newEl.style.height = '100%';

        var elItem = {  element: newEl, 
                                      id: newEl.id,
                                      name: newEl.tagName.toLowerCase(), 
                                      top: top,
                                      left: left,
                                      category: cat,
                                      colorClass: colorClass,
                                      varName: newEl.varName,
                                      publicMethods: newEl.publicMethods
                                  };

        var info = this.$.component_list.getComponentInfo(newEl.tagName.toLowerCase());

        if (elItem.name.indexOf('destination') > -1) {
          elItem.resizable = false;
          setTimeout(function() {

            // TO DO: only one destination
            self.destinations.push(elItem);
          }, 200);
        } else {
          elItem.resizable = true;
        }

        self._addElementVar(elItem)

        self._initCustomMethodsObj(elItem);

      },

      // find the ID of the event target that was clicked
      _deleteEvent: function(e) {
        var compId = e.target.getAttribute('component_id');
        if(confirm('Do you want to remove this element from the sketch?')) {
          this._deleteElement(compId);
        }
      },

      // delete element by ID
      _deleteElement: function(compId) {

        var self = this;
        var embeddedEl = self.querySelector('#'+compId);
        var elInArray = self.findElById(compId);

        // remove element from elements array (which removes it from the shadowDOM)
        var filteredEls = self._elements.filter(function(el) {
            return el.element.id!==compId;
        });
        self._elements = filteredEls;

        // remove _customMethods associated with this element
        var newCustomMethods = {};

        for (var i in self._customMethods) {
          if (i !== compId) {
            newCustomMethods[i] = self._customMethods[i];
          }
        }

        self._customMethods = newCustomMethods;

        // remove elements
        self.removeChild(embeddedEl);

        // remove var from olos object
        this[embeddedEl.varName] = null;

        //remove all connections
        self.removeAllConnectionsFromElement(compId)

        // dispose will remove this element's audio nodes and animation loops / p5 sketches / nexusUI
        embeddedEl.dispose();
      },

      removeAllConnectionsFromElement: function(elId) {

        var badConnections = this._connections.filter(function (conn, index) {
          
          //filter if element is source or target of a connection
          return (conn.source.id===elId || conn.target.id === elId);
           
        });

        var goodConnections = this._connections.filter(function (conn, index) {
          
          //filter if element is source or target of a connection
          return !(conn.source.id===elId || conn.target.id === elId)
           
        });

        this._connections = goodConnections;

        // disconnect the badConnections
        for (var i = 0 ; i < badConnections.length; i++) {
          var src = badConnections[i].source.element[badConnections[i].source.field];
          if (src instanceof AudioNode) {
            this._deleteAudioConnection(badConnections[i]);
          } else {
            // console.log('removed connection ' + src + ' is not audio!!');
          }
        }

        this._drawConnections();

      },

      _deleteAudioConnection: function(connection) {
        var self = this;
        var srcElem = connection.source.element;
        var srcField = connection.source.field;
        var srcNode = srcElem[srcField];
        try{
          srcNode.disconnect();
        } catch(e) {
          self.deleteConnection(connection);
        }

        // reconnect any connections that have srcNode as the source
        for (var i = 0; i < this._connections.length; i++) {
          var conn = this._connections[i];

          if (conn.source.element === srcElem && conn.source.field === srcField) {
            var dstElem = conn.target.element;
            var dstField = conn.target.field;
            var dstNode = dstElem[dstField];
            srcNode.connect(dstNode);
          }
        }

      },


      /********************** Event Handlers Start ********************************/

      draggedOverContainer: function(e) {
        // Needed to enable droppedInContainer
        e.preventDefault();
      },

      droppedInContainer: function(e, detail, selection){
        var self = this;

        //dont know why this method is being called instead of resizedragend?!
        if(e.path && e.path.length>0 &&  e.path[0].classList.contains('resize')>0) {
          self.dragResizeEnd(e, detail, selection);

        }

        var dataTransfer = e.dataTransfer.getData('text/plain');
        // console.log(dataTransfer);
        //data added by olos-component-list //TODO make better
        if(dataTransfer && dataTransfer.length>0) {
          var dataSeg = dataTransfer.split(',');

          // dataSeg[0] is component name, dataSeg[1] is categoryIndex
          if(dataSeg.length==2) {
            self.addNewElToConnector(dataSeg[0], dataSeg[1], Math.round(e.offsetX/10)*10 * self._zoom, Math.round(e.offsetY/10)*10 * self._zoom);

            return;
          } 

        }

      },

      dragStartResize: function(e, details, selection) {
         e.stopPropagation();
      },

      dragResize: function(e, details, selection) {

          var self = this;

          var wrapper = selection.parentNode;
          //var styles = window.getComputedStyle(wrapper);
          // var wrapperTop = parseInt(styles.top.replace('px',''));
          // var wrapperLeft = parseInt(styles.left.replace('px',''));

          // var w =  e.x - wrapperLeft - 65,
          //     h = e.y - wrapperTop - 172;

          var wrapperTop = parseInt(wrapper.getBoundingClientRect().top),
              wrapperLeft = parseInt(wrapper.getBoundingClientRect().left);
          

          var w =  e.x/this._zoom - wrapperLeft,
              h = e.y/this._zoom - wrapperTop;


          // wrapper.style.width = w +'px';
          // wrapper.style.height = h +'px';

          var elementInsideId = wrapper.getAttribute('component-id');//wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);

          var element = this.findElById(elementInsideId);

          element.width = w;
          element.height = h;

          // element.shadowRoot.container.width = w;
          // element.shadowRoot.container.height = h;

          self._drawConnections();

          // RESIZE
          self.resizeEl(elementInside);
          // <-- end Resize

          e.stopPropagation();
          e.preventDefault();


        },

        dragResizeEnd: function(e, details, selection) {

          var wrapper = null, self = this;

          if(e.path && e.path.length>0 &&  e.path[0].classList.contains('resize')>0) {
            
            wrapper = e.path[0].parentNode;

          }

          var elementInsideId = wrapper.id.replace('wrapper-','');
          var elementInside = this.querySelector('#'+elementInsideId);

          self.resizeEl(elementInside);

        },


        dragStartWrapper: function(e, details, selection) {

          var target = e.target;

          target.setAttribute('start-x', e.x);
          target.setAttribute('start-y', e.y);

          var dragImgEl = document.createElement('span');
          dragImgEl.setAttribute('style','opacity: 0' );
          dragImgEl.textContent = 'a';

          // add it to the document
          document.body.appendChild(dragImgEl);
          e.dataTransfer.setDragImage(dragImgEl,-200,-200);          
          
          // select this element
          var wrapperEl = selection;
          if(this._selWrapper) {
            this._selWrapper.classList.remove('selected-element');
          }
          this._selWrapper = wrapperEl;
          this._selWrapper.classList.add('selected-element');

          var elementId = wrapperEl.id;
          elementId = elementId.substring(8, elementId.length);

          // reset this._selElement
          try {
            this._selElement = this.findElById(elementId).element;
          } catch(e) {
            // set selection to destination
            this._selElement = this._elements[0];
          }

        },

        dragWrapper: function(e, details, selection) {

          if(e.path[0].classList && e.path[0].classList.length>0 && 
            (e.path[0].classList.contains('resize') || e.path[0].classList.contains('arrow'))) {
            return false;
          };

          try {
            var target = e.target; // || selection; //e.target || e.path[0];

            var dx = e.x/this._zoom - (target.getAttribute('start-x')/this._zoom || 0),
                dy = e.y/this._zoom - (target.getAttribute('start-y')/this._zoom || 0);


                // keep the dragged position in the data-x/data-y attributes, add snap residue from previous drag
                var x = (parseFloat(target.getAttribute('data-x')) || 0) + dx + (parseFloat(target.getAttribute('residue-x')) || 0);
                var y = (parseFloat(target.getAttribute('data-y')) || 0) + dy + (parseFloat(target.getAttribute('residue-y')) || 0);

                sx = Math.round(x/this._snapX)*this._snapX;
                sy = Math.round(y/this._snapY)*this._snapY;

                target.setAttribute('residue-x', x - sx );
                target.setAttribute('residue-y', y - sy);


                // translate the element. 
                // last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
                if(e.x!==0 ||  e.y!==0)
                {
                /*
                  target.style.webkitTransform =
                        target.style.transform = 'translate(' + sx + 'px, ' + sy + 'px)';
                */

                  var componentId = target.getAttribute('component-id');

                  this.findElById(componentId).transform = 'translate(' + sx + 'px, ' + sy + 'px)';

                  // update the position attributes
                  // 
                  target.setAttribute('data-x', sx);
                  target.setAttribute('data-y', sy);
                  

                  target.setAttribute('start-x', e.x);
                  target.setAttribute('start-y', e.y);

                  this._drawConnections();

                }
           } 
           catch(e){console.log('ERROR: ' + e)}

        }, 

        dragEndWrapper: function(e, details, selection) {
          
          
          //if resize is being dragged don't do anything (stopPropagation is not doing anything)
          // if(e.path[0].classList && e.path[0].classList.length>0 && e.path[0].classList.contains('resize')) {
          //   return false;
          // }

          var target = e.target;
          target.setAttribute('residue-x', 0 );
          target.setAttribute('residue-y', 0);

          
        }, 

        wrapperClicked: function(e, detail, selection) {
          var wrapperEl = selection;
          if(this._selWrapper) {
            this._selWrapper.classList.remove('selected-element');
          }
          this._selWrapper = wrapperEl;
          this._selWrapper.classList.add('selected-element');

          var elementId = wrapperEl.id;
          elementId = elementId.substring(8, elementId.length);

          // reset this._selElement
          this._selElement = this.findElById(elementId).element;
        },

        // SVG drag events, also called on mousedown
        dragStartSVG: function(e, details, selection) {
          this._makeDragArea = true;
          this._selectingElByDrag = false;

          this._dragArea = this._createDragArea(e, details, selection);

          this.$.svg.insertBefore(this._dragArea, this.$.svg.firstChild);
        },

        // called when makeDragArea is true
        dragSVG: function(e, details, selection) {
          if (this._makeDragArea) {
            this._updateDragArea(e, this._dragArea);
          }
        },

        // also called on mouseup
        dragEndSVG: function(e, details, selection) {

          if (!this._dragArea) {
            return;
          }

          // remember the old sel el
          var oldSelElement = this._selElement;

          // dimension of the rectangle:
          var dragRect = this._dragArea.getBoundingClientRect();

          // find any elements that intersect with the drag area, sort out which are _selElement and _selWrappers
          for (var i in this._elements) {
            var el = this._elements[i];

            var wrapperEl = this.shadowRoot.querySelector('#wrapper-' + el.id);

            // get element dimensions
            var elRect = wrapperEl.getBoundingClientRect();

            // compare and if there is overlap, add class
            var overlap = this._boundingRectOverlap(elRect, dragRect);

            if (overlap) {
              // select elements that overlap
              if (this._selWrappers.indexOf(wrapperEl) < 0) {
                this._selWrappers.push(wrapperEl);
              }
              wrapperEl.classList.add('selected-element');

              // remember selected element if it overlaps
              if (el.element === oldSelElement) {
                this._selElement = el.element;
              }
            }
            else {
              // otherwise remove selection
              if ( wrapperEl.classList.contains('selected-element') ){
                wrapperEl.classList.remove('selected-element');
              } if (this._selElement === el.element) {
                this._selElement = null;
              }
            }

          }

          this._makeDragArea = false;
          this._clearDragArea(this._dragArea);
          this._dragArea = null;

        },

        // helper method
        _boundingRectOverlap: function(rect1, rect2) {
          var overlap = !(rect1.right < rect2.left || 
                          rect1.left > rect2.right || 
                          rect1.bottom < rect2.top || 
                          rect1.top > rect2.bottom)
          return overlap;
        },

        // handle selecting elements by their wrapper during drag
        dragOverWrapper: function(e, details, selection) {
          // if (this._makeDragArea) {
          //   if (!this._selectingElByDrag) {
          //     this._selectingElByDrag = true;
          //   }

          //   console.log('drag over: ' + e.target.id);
          // }
        },

        // create a rectangle to show drag area
        _createDragArea: function(e) {
          var x = e.x / this._zoom, y = e.y / this._zoom;
          var svgns = "http://www.w3.org/2000/svg";
          var rect = document.createElementNS(svgns, 'rect');
          rect.setAttributeNS(null, 'opacity', 0.2);
          rect.setAttributeNS(null, 'x', x);
          rect.setAttributeNS(null, 'y', y);
          rect.setAttributeNS(null, 'width', '0');
          rect.setAttributeNS(null, 'height', '0');
          rect.setAttributeNS(null, 'fill', '#D1D1D1');
          rect.startX = x;
          rect.startY = y;
          return rect;
        },

        // update drag rectangle
        _updateDragArea: function(e, rect) {
          var svgns = "http://www.w3.org/2000/svg";
          var startX = rect.startX;
          var startY = rect.startY;
          var deltaX = e.x/this._zoom - startX;
          var deltaY = e.y/this._zoom - startY;

          if (deltaX < 0) {
            rect.setAttributeNS(null, 'x', startX + deltaX);
            deltaX = Math.abs(deltaX);
          }

          if (deltaY < 0) {
            rect.setAttributeNS(null, 'y', startY + deltaY);
            deltaY = Math.abs(deltaY);
          }

          rect.setAttributeNS(null, 'width', deltaX);
          rect.setAttributeNS(null, 'height', deltaY);
        },

        _clearDragArea: function(rect) {
          //this.$.svg.innerHTML = '';
          this.$.svg.removeChild(rect);
        },


        // OUT ARROWS
        dragOutArrowStart: function(e, details, selection) {

          this.draggedEl = selection;
          //to stop wrapper drag to be called
          // e.stopPropagation();

          if(!this.svgTop || !this.svgLeft) {

            var svgRect = this.$.svg.getBoundingClientRect();
            this.svgTop = svgRect.top;
            this.svgLeft = svgRect.left;

          }


          this.startPointX = e.x/this._zoom - this.svgLeft;
          this.startPointY = e.y/this._zoom - this.svgTop;

          // create temp bezier
          this._addBezierPath( this.startPointX , this.startPointY , this.startPointX , this.startPointY , 70, 'temp_path');
          //this._addBezierPath( event.x0 , event.y0 , event.x0 , event.y0 , 70, 'temp_path');
        },

        dragOutArrow: function(e, details, selection) {
          var tempPath = this.shadowRoot.querySelector('#temp_path');

          // the last dragMove call passes e.x=0 and e.y=0 which causes neg x,y values. this if avoids that
          if(e.x!==0 ||  e.y!==0)
          {

            var newPath = this._createBezierPath( this.startPointX, this.startPointY , e.x/this._zoom - this.svgLeft  , e.y/this._zoom - this.svgTop  , 70);
            tempPath.setAttribute('d',newPath);
          }               

        },

        dragOutArrowEnd: function(e, details, selection) {

          var tempPath = this.shadowRoot.querySelector('#temp_path');
          if(tempPath) {
            tempPath.parentNode.removeChild(tempPath);
          }

        },

        resizeEl: function(elementInside) {
          if(typeof elementInside.resize ==='function') {
            elementInside.resize();
          }
        },


        // IN ARROWS
        dragOverInArrow: function(e, details, selection) {
          //important! needed to allow drop
          e.preventDefault();

        },

        dragEnterInArrow: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },

        dragLeaveInArrow: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },

        mouseEnterCnx: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },

        mouseLeaveCnx: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },

        droppedOnInArrow: function(e, details, selection) {

          var self = this;

          e.target.classList.remove('drag-over');

          var className = selection.classList[0],
              targetElementId = className.substring(0, className.lastIndexOf('-') ),   
              targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),      
              source = self.findElById(self.draggedEl.classList[0]),
              target = self.findElById(targetElementId);

          this._connectAttributes(source, 'output', target, targetField);

          self._drawConnections();

          e.stopPropagation();

        }, 

        // PARAMS
        dragOverParamArrow: function(e, details, selection) {
          //important! needed to allow drop
          e.preventDefault();
        },

        dragEnterParamArrow: function(e, details, selection) {
          e.target.classList.add('drag-over');
        },

        dragLeaveParamArrow: function(e, details, selection) {
          e.target.classList.remove('drag-over');
        },

        droppedOnParamArrow: function(e, details, selection) {
          var self = this;
          e.target.classList.remove('drag-over');

          var className = selection.classList[0],
              targetElementId = className.substring(0, className.lastIndexOf('-') ),   
              targetField = className.substring(className.lastIndexOf('-') + 1, className.length ),      
              source = self.findElById(self.draggedEl.classList[0]),
              target = self.findElById(targetElementId);

          // connect source to audioParam
          this._connectAttributes(source, 'output', target, targetField);
          // self._drawConnections();
          e.stopPropagation();
        }, 

        arrowClicked: function(e, details, selection) {
          //e.stopPropagation();

          var wrapper = null;
          var isAudioParam = false;

          for(var i = 0; i< e.path.length && !wrapper; i++) {
            if(e.path[i].classList.contains('wrapper')) {
              wrapper = e.path[i];
            }
          }

          // paramMarker is also a target
          var sourceTarget = e.path[0].classList.contains('outputMarker') ? 'source' : 'target';

          // TO DO: use this.
          if (e.path[0].classList.contains('paramMarker')) {
            isAudioParam = true;
          }

          var elementInsideId = wrapper.getAttribute('component-id');

          var connection = this._connections.filter(function(conn) {
            if(conn[sourceTarget].id===elementInsideId) {
              return true;
            }

          });


          if(connection.length>0) {

            var marker = e.path[0];
            var bezierCssPath = '#container #svg #'+connection[0].source.id+'-'+connection[0].target.id;

            var bezier = this.shadowRoot.querySelector(bezierCssPath);
            this._highlightedConnection = bezier;

            if(connection[0].highlighted) {
              connection[0].highlighted = false;

              marker.classList.remove('highlighted');
              bezier.classList.remove('highlighted');

            }
            else {

              connection[0].highlighted = true;

              marker.classList.add('highlighted');
              bezier.classList.add('highlighted');
            }
            // this._highlightedConnection = null;
          }
        },


        highlightBezier: function(bezier, connection) {
          bezier.classList.add('highlighted');
          // connection status is highlighted
        },

        deleteConnection: function(e, details, selection) {
          var dst;
          var src;

          if (e) {
            e.stopPropagation();
          }

          if (this._highlightedConnection) {
            var splitID = this._highlightedConnection.id.split('-');
            src = splitID[0]+'-'+splitID[1]+'-'+splitID[2];
            dst = splitID[3] + '-' + splitID[4] + '-' + splitID[5];
          }
          else {
            var wrapper = null;
            for(var i = 0; i< e.path.length && !wrapper; i++) {
              if(e.path[i].classList.contains('wrapper')) {
                wrapper = e.path[i];
              }
            }
            dst = wrapper.getAttribute('component-id');
          }

          // -- or --
          // delete all connections / reconnect everything
          var srcNode, srcElem;
          for (var i = 0; i < this._connections.length; i++) {

            if (this._connections[i].target.id === dst && this._connections[i].source.id === src) {
              srcNode = this._connections[i].source.field;
              srcElem = this._connections[i].source.element;
              dstNode = this._connections[i].target.field;
              dstElem = this._connections[i].target.element;

              // if destination is a script processor, delete it
              if (dstElem[dstNode] instanceof ScriptProcessorNode) {
                console.log('deleting script processor node');
                dstElem[dstNode].disconnect();
                dstElem[dstNode] = [];
              } else if (dstElem[dstNode] instanceof Array) {
              // if destination is an array, make it empty
                dstElem[dstNode] = [];
              }

              try {
                srcElem[srcNode].disconnect();
              } catch(e) {
                // if unable to disconnect it is probably just data so no worries
                console.log('unable to disconnect ' + srcElem[srcNode]);
              }
              this._connections.splice(i,1);
            }
          }

          // if srcNode was connected to any other nodes, re-connect them
          for (var j = 0; j < this._connections.length; j++) {
            var src = this._connections[j].source;
            if (src.element === srcElem && src.field === srcNode) {
              var dstNode = this._connections[j].target.field;
              var dstElem = this._connections[j].target.element;
              try {
                srcElem[srcNode].connect(dstElem[dstNode]);
              } catch(e) {
                console.log(e);
              }
            }
          }

          // var marker = e.path[1]; 
          // console.log(marker);
          this._highlightedConnection.classList.remove('highlighted');
          this._highlightedConnection = null;

          this._drawConnections();

        },

        _scrollHandler: function(e) {
          console.log('scrolling');
          this._drawConnections();
        },



      /********************** Event Handlers End ********************************/


      /**
       * The functions which sets the connection (two way binding) between two element attrubutes
       * There is not really a source/target distinction in the observer since it is a two way binding (in theory)
       * but the distinction is conceptual and in UI.
       * @param  {[type]} source      Source element
       * @param  {[type]} sourceField The attribute to connect from source element
       * @param  {[type]} target      Target element
       * @param  {[type]} targetField The attribute to connect from target element
       * @return {None}             
       */
      _connectAttributes: function(source, sourceField, target, targetField) {
        var self = this;

        //find the index of connection which has the same target
        var connWithSameTargetIndex = self._connections.reduce(function(value, conn, index) {
            if (conn.target.id===target.id && conn.target.field===targetField && conn.source.id===source.id && conn.source.field === conn.sourceField) {
              return index;
            }

        }, -1);
        // and remove it from connections array
        if(connWithSameTargetIndex>-1) {
          self._connections.splice(connWithSameTargetIndex,1);
        }


        if (source === target){ //if a bubble was dropped on itself
          console.log('You cannot make a connection within the same element');
          return false;
        } else { 

          var srcClone = {id: source.id, name: source.name, element: source.element};
          var targetClone = {id: target.id, name: target.name, element: target.element};

          targetClone.field = targetField;
          srcClone.field = sourceField;

          // make the actual connection, returns true if connection was made
          if ( this.makeConnection(source.element, sourceField, target.element, targetField) ) {
            this._connections.push({source: srcClone, target: targetClone});
          }

          return true;
        }

      },

      _drawConnections: function() {

        var self = this;


        var arrowOffsetY = 16;
        var arrowOffsetX = 0;
        var bezierCurveX = 45;  // the larger the value the smoother the curve


        //clear all paths. since it is not done often it is fine to do it in a not optimized way
        self.$.svg.innerHTML = '';

        for (var i = 0; i < self._connections.length; i++) {


          var conn = self._connections[i];

          var srcEl = conn.source.element || self.querySelector('#'+conn.source.id); //TODO do this in initialization method
          var targetEl = conn.target.element || self.querySelector('#'+conn.target.id);

          // isAudioParam determines offset of the connection target
          var isAudioParam = conn.target.field.indexOf('Param') > -1 ? true : false;

          // no zoom if connected to destination
          var isDestino = conn.target.name.indexOf('destination') >= 0;
          var end_zoom = isDestino ? self._zoom : self._zoom;

          var srcWrapper = self.shadowRoot.querySelector('#wrapper-'+srcEl.id);
          var targetWrapper = self.shadowRoot.querySelector('#wrapper-'+targetEl.id);

          var srcRect = srcWrapper.getBoundingClientRect();
          var targetRect = targetWrapper.getBoundingClientRect();

          var svgRect = self.$.svg.getBoundingClientRect();

          // param offset... TO DO find a better place for this
          var paramOffset = (conn.target.field.indexOf('Param') > -1) ? [0, targetRect.height - 25] : [0,0];

          var startX = (srcRect.right - svgRect.left + arrowOffsetX)/self._zoom; //srcRect.left + srcRect.width + 30 - containerOffsetX;
          var startY = (srcRect.top - svgRect.top + arrowOffsetY)/self._zoom;
          var endX = (targetRect.left  - svgRect.left - arrowOffsetX + paramOffset[0])/end_zoom;
          var endY = (targetRect.top  - svgRect.top + arrowOffsetY + paramOffset[1])/end_zoom;


          self._addBezierPath(startX, startY, endX, endY , bezierCurveX, srcEl.id + '-' + targetEl.id, conn.highlighted, isAudioParam);
          
        }

      },


      /**
       * Sacffold a new th-connector from state data. Usage: 
       *  var newConnector = document.createElement('th-connector');
       *  newConnector.scaffoldFromData(elements, connections)
       *  where elements and connections are parsed json files coming form dumpStateDataAsString
       * @param  {Object} elements    elements state data
       * @param  {Object} connections connections
       * @return {None}             
       */
      
      scaffoldFromData: function(elements, connections, customMethods) {
        var self = this;

        // reset everything
        // this._environmentClear();
        this.reFresh();

        // this._elements = elements;

        // TO DO: do not save / re-create Destination

         elements.forEach(function(el) {
            var alreadyExist = this.querySelector('#'+el.id);
            if(!alreadyExist) {

              var domEl =  document.createElement(el.name);


              this.$.component_list.checkAndImport(domEl, function() {

                domEl.style.width = '100%';
                domEl.style.height = '100%';

                domEl.id = el.id;
                
                // Object.keys(domEl.publish).forEach(function(attr) {
                Object.keys(domEl.publish).forEach(function(attr) {

                  if(attr!=='input' && attr!=='output' && el[attr]) {
                    domEl[attr] = el[attr]; 
                  }

                });

                this.appendChild(domEl);

                // will this work? //////////// *********************** \\\\\\\\\\
                // this._processNewElement(domEl, domEl.top, domEl.left, this._colors.indexOf(domEl.colorClass) );
                // el.element = domEl;
               this.setupElement(domEl, el);

              // add global var
              olos[el.varName] = el;

             }.bind(this));

            }

          }.bind(this));

         //delay to make sure position of elements are final
         setTimeout(function() {

          this.setConnections(connections);

          // clone custom methods
          var methodKeys = Object.keys(customMethods);
          methodKeys.forEach(function(key) {
            self._customMethods[key] = customMethods[key];

            // TO DO: execute the custom methods
          });

         }.bind(this),1000);

        //newConnector._drawConnections()

      },

      // set up an element that has been added to the sketch
      setupElement: function(domEl, el) {
        var self = this;

        var elItem = {  element: domEl, 
                              id: domEl.id,
                              name: domEl.tagName.toLowerCase(), 
                              top: el.top,
                              left: el.left,
                              category: el.category,
                              colorClass: el.colorClass,
                              varName: el.varName,
                              publicMethods: el.publicMethods
                          };

        // attributes that were not assigned to domEl b/c they were not published
        domEl.varName = el.varName; // used by sourcecode element
        domEl.name = domEl.tagName; // used by docs
        domEl.publicMethods = el.publicMethods;


        // domEl.colorClass = el.colorClass;


        var info = this.$.component_list.getComponentInfo(domEl.tagName.toLowerCase());

        if (elItem.name.indexOf('destination') > -1) {
          elItem.resizable = false;
          setTimeout(function() {

            // only one destination
            // var oldDest = self.destinations.pop();
            // oldDest.dispose();

            self.destinations.push(elItem);
          }, 200);
        } else {
          elItem.resizable = true;
        }

        self._addElementVar(elItem)

        self._initCustomMethodsObj(elItem);
      },

      setConnections: function(connections) {
        this._connections = connections;


        this._connections.forEach(function(connection) {
          if(!connection.source.element) {
            connection.source.element = this.querySelector('#'+connection.source.id);
          }
          if(!connection.target.element) {
            connection.target.element = this.querySelector('#'+connection.target.id);
          }
          this._connectAttributes(connection.source, 'output', connection.target, connection.target.field || 'input');
        }.bind(this));

        this._drawConnections();
      },

      dumpStateDataAsString: function() {
        var self = this;

        var toDumpEls = _.map(this._elements, function(el) {
          var domObject = el.element;
          var cloned = _.clone(el);
          Object.keys(domObject.publish).forEach(function(attr) {
            //ignore input attribute and output (except where the component is th-table-data)
            if(attr.indexOf('input')===0 || (attr==='output' )) {
              return;
            }
            cloned[attr] = domObject[attr];
          });

          return cloned;
        });

        var retObj = {elements: toDumpEls, connections: this._connections, customMethods: this._customMethods};

        var ret = JSON.stringify(retObj, this.removeDomObjects);
        //var connectionsJSON = JSON.stringify(this._connections , this.removeDomObjects);

        return ret;
      },

      saveToLocalStorage: function() {
        var sketchData = this.dumpStateDataAsString();
        var sketchName = this.$.filename.value;
        localStorage.setItem(sketchName, sketchData);
      },

      _loadFromLocalStorage: function(sketchName) {
        var sketchString = localStorage[sketchName];
        var sketchJSON = JSON.parse(sketchString);
        this.scaffoldFromData(sketchJSON.elements, sketchJSON.connections, sketchJSON.customMethods);
      },

      _loadSavedFile: function(e, detail, selection) {
        var fileName = this.$.fileLoader.selectedItem.getAttribute('label');
        try {
          this._loadFromLocalStorage(fileName);
        } catch(e) {throw 'unable to load ' + fileName}
      },

      removeDomObjects: function(key, value) {

          if(value instanceof HTMLElement) 
            return undefined;
          else
            return value;

      },


      findElById: function(id){

        var self = this;
        element = self._elements.filter(function(el){
          return el.id === id;
        })[0];

        return element;
      },



      /**
       * Checks if a componenet has input attributes (any attribute which is named input*)
       * @param  {Object} published Object containing all published attributes
       * @return {Object}           list of attributes that are input.
       */
      _checkForInputAttr: function(published){

        if(!published) {
          return false;
        }
        var attrs = Object.keys(published).filter(function(item) {
          return item.indexOf("input") > -1;

        });

        return attrs;
      },
     
      /**
       * Checks if a component has output attributes.
       * @param  {Object} published Object containing all published attributes
       * @return {boolean}       True if component has output attribute (only one)
       */
      _checkForOutputAttr: function(published){
        if(!published) {
          return false;
        }

        return Object.keys(published).indexOf("output") > -1 ? true : false;
      },

      /**
       *  Checks if a component has audioParams. AudioParams must have 'param'
       *  in the name and be published attributes.
       *  
       *  @param  {Object} published Object containing all published attributes
       *  @return  {Oobject} list of attributes that are audioParams.
       */
      _checkForAudioParams: function(published) {
        if(!published) {
          return false;
        }
        var attrs = Object.keys(published).filter(function(item) {
          return item.toLowerCase().indexOf("param") > -1;
        });

        return attrs;
        // console.log(published.audioParams);
        // return published.audioParams;

        // var audioParams = [];
        // var audioParamKeys = keys.filter(function(key){return newEl.audioParams; });
        // console.log('hi');
        // for (var j in audioParamKeys) {
        //   var audioNode = newEl[audioParamKeys[j]];
        //   for (var i in audioNode) {
        //     if (audioNode[i] instanceof AudioParam) {
        //       audioParams.push(audioNode[i]);
        //     }
        //   }
        // }
        // console.log(audioParams);
        // return audioParams;
      },

      /**
       * Generates unique ids for components
       * @param  {String} elName Component name
       * @return {[type]}        Unique component id
       */
      _generateUniqueId: function(elName){
          var self = this;
          var num = 0;

          var tagsWithSameName = self._elements.filter(function(elem){return elem.name == elName});
          
          if(tagsWithSameName){
            num+= tagsWithSameName.length;
          }

          for (var i = 0; i < self._elements.length; i++) {
            var elem = self._elements[i];
            if (elem.name == elName) {
              var elNum = elem.id.split('-').pop();
              num = Math.max(elNum, num);
            }
          }

          num++;

          // var existingIds = self._elements.filter(function(elem){ return elem.name == elName})

          var uniqueId = elName + '-' + num;
          return uniqueId;
      }, 

      // convert from an input like olos-element-name-0 to "elementName0"
      _generateVarName: function(elId) {
        // remove split at '-' and remove 'olos' first item from array
        var arr = elId.split('-').slice(1);
        var varName = '';

        varName = arr[0];

        // if varName has additioal stuff, like sound-file, return soundFile
        for (var i = 1; i < arr.length; i++ ) {
          var capString = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
          varName += capString;
        }

        return varName;
      },

      // store element variable name, and include it in olos.elements Array
      _addElementVar: function(elItem) {
        this._elements.push(elItem);

        olos[elItem.varName] = elItem.element;
      },

      // set element variable name to null, and remove it from olos.elements Array
      _removeElementVar: function(elItem) {

      },

      _createBezierPath: function(startX, startY, endX, endY, handleOffsetX) {

          // make handleOffsetX larger when source element is on the right side of target
          if(startX > endX) {
            handleOffsetX *= 2;
          }
          var distance = Math.sqrt(Math.pow(endX-startX, 2) + Math.pow(endY-startY,2));
          // decrease handleOffsetX when too close...
          if(distance<100) {
             handleOffsetX /= 2;
          }
          if(distance<50) {
             handleOffsetX /= 4;
          }
          var path = "M"+parseInt(startX)+","+parseInt(startY)+
                     " C"+parseInt(startX + handleOffsetX)+","+parseInt(startY)+
                     " "+parseInt(endX - handleOffsetX)+","+parseInt(endY)+
                     " "+parseInt(endX)+","+parseInt(endY);
          return path;
      },

      _addBezierPath: function(startX, startY, endX, endY, handleOffsetX, id, highlighted, isParam) {

          var aLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); 
          var path = this._createBezierPath(startX, startY, endX, endY, handleOffsetX);

          aLine.setAttributeNS(null, 'd',path);
          aLine.setAttributeNS(null, 'stroke', '#555');// conn.source.color);
          aLine.setAttributeNS(null, 'stroke-width', '5');
          aLine.setAttributeNS(null, 'fill-opacity', '0');
          aLine.setAttribute('class', 'cnxn');

          if(id) {
            aLine.setAttributeNS(null, 'id', id);
          }

          if(highlighted) {
            aLine.classList.add('highlighted');
          }
          
          if(isParam) {
            aLine.classList.add('param');
          }

          _dragObj.connectorShape = aLine;
          this.$.svg.insertBefore(aLine, this.$.svg.firstChild);

      },


      // zoom either to a specified amount, or add this._zoomStep
      zoomIn: function(amt) {
        if (typeof(amt) === 'number') {
          this._zoom = amt <= this._zoomMax ? amt : this._zoomMax;
          return;
        }

        if (this._zoom + this._zoomStep <= this._zoomMax) {
          this._zoom += this._zoomStep;
        } else { throw 'already zoomed max'; }

      },

      // zoom either to a specified amount, or subtract this._zoomStep
      zoomOut: function(amt) {
        if (typeof(amt) === 'number') {
          this._zoom = amt >= this._zoomMin ? amt : this._zoomMin;
          return;
        }

        if (this._zoom - this._zoomStep >= this._zoomMin) {
         this._zoom -= this._zoomStep;

        } else { throw 'already zoomed min'; }

      },

      _zoomChanged: function() {
        var self = this;
        self.$.container.style.transform = "scale(" + self._zoom +", " + self._zoom+")";

        var id = setInterval(function() {
          self._drawConnections();
        }, 50);

        setTimeout(function() {
          window.clearInterval(id);
        }, 600);

      },


      //// olos environment

      makeConnection: function(src, srcPort, dst, dstPort, svgPath) {

        var isAudioParam = dstPort.indexOf('Param') > -1 ? true : false;
        var connectorShape = {};

        if (_dragObj && _dragObj.connectorShape) {
          connectorShape = _dragObj.connectorShape;
        }

        // Put an entry into the source's outputs
        if (!src.outputConnections)
            src.outputConnections = new Array();
        var connector = new Object();
        connector.line = connectorShape;
        connector.source = src;
        connector.destination = dst;
        connector.sourcePort = src[srcPort];
        connector.destinationPort = dst[dstPort];
        connector.destinationLabel = dstPort;
        src.outputConnections.push(connector);

        // Put an entry into the destinations's inputs
        if (!dst.inputConnections){
          dst.inputConnections = new Array();
        }
        connector = new Object();
        connector.line = connectorShape;
        connector.source = src;
        connector.destination = dst;
        connector.sourcePort = src[srcPort];
        connector.destinationPort = dst[dstPort];
        connector.destinationLabel = dstPort;
        dst.inputConnections.push(connector);

        connectorShape.inputConnection = connector;
        connectorShape.destination = dst;

        // make path clickable
        // connectorShape.addEventListener('onclick',clickedOnConnection);

        connectorShape = null;
        // save connections to component source and destination
        if (src[srcPort] instanceof AudioNode && dst[dstPort] instanceof AudioNode) {
          src[srcPort].connect(dst[dstPort]);
        } else if (dst[dstPort] instanceof AudioParam) {
          console.log('audio param connection!');
          src[srcPort].connect(dst[dstPort]);
        }


        else if (dst[dstPort] instanceof Array) {
          console.log('this option0');
          // add to destination array
          // dst[dstPort].push(src[srcPort]);
        }
        else {
          // ssrc[srcPort]
          console.log('could not make a connection');
          return false;
        }

        return true;
      },


      // clickInContainer helps detect if a bezier was clicked
      clickInContainer: function(e) {
        var className = e.toElement.className;
        if ( className.baseVal && className.baseVal.indexOf('cnxn') > -1 ) {
          this.clickedOnConnection(e);
        } else {
          this._clearHighlightedConnections();
        }

        // start drag
        if (e.target.id === 'container') {
          this.dragStartSVG(e);
        }
      },

      // called by connectorShape object, this = the instance of that object when it deletes itself.
      clickedOnConnection: function(e) {
        // this._highlightedConnection = the most recently clicked on connection
        this._highlightedConnection = this.shadowRoot.querySelector('#'+e.toElement.id);

        // if this._highlightedConnection is already highlighted, delete the connection represented by this._highlightedConnection
        if (String(this._highlightedConnection.classList).indexOf('highlight') > -1 ) {
          this.deleteConnection(e);
        } else {
          // if not highlighted, then highlight
          this.highlightBezier(this._highlightedConnection);
        }

        // var connections = this.destination.inputConnections;
        // breakSingleInputConnection( connections, connections.indexOf( this.inputConnection ) );

      },


      _clearHighlightedConnections: function() {
        if (this._highlightedConnection) {
          this._highlightedConnection.classList.remove('highlighted');
          this._highlightedConnection = null;
        }
      },

      // list public methods in dropdown
      _listPublicMethods: function(el) {
        // var codeEditor = this.$.codeeditor;

        // find this element's public methods
        var publicMethods = el.publicMethods;

        // TO DO: showpublicmethodsinavenue
        if (typeof(publicMethods) !== 'undefined') {
          for (var i = 0; i < publicMethods.length; i++) {

          }
        }
      },

      // show code in the codeEditor
      _showCode: function(el) {
        var self = this;
        var codeEditor = this.$.codeeditor;
        var publicMethods;

        // find this element's public methods
        try {
          publicMethods = el.publicMethods;
        } catch (e) {
          throw 'unable to show code';
          return;
        }

        // this._setupMethodDropdown(publicMethods);

        // for now, just show the first editable method
        // var methodIndex = 0;

        // show code TO DO: make multiple parts editable
        // var displayCode = String(el.publicAudio);

        if (typeof(publicMethods) !== 'undefined' && publicMethods.length > 0) {
          // var methodName = publicMethods[methodIndex];
          var methodName = this._selectedMethod;
          var displayCode;

          // if we have already set a custom value for this method, display that
          if (typeof (this._customMethods[el.id][methodName]) !== 'undefined'){
            displayCode = this._customMethods[el.id][methodName];
            console.log('the code already exists! and is...' );
          } else {
            displayCode = String(el[methodName]);
            // remove first and last lines of the function to only show its contents
            displayCode = displayCode.split('\n');
            displayCode.shift();
            displayCode.pop();

            // remove indentation so it looks nice
            displayCode.forEach(function(row, index){
              if (row[0] === '\t') {
                // remove the tab
                row = row.substr(1);
              } else if (row[0] === ' ' && row[1] === ' '){
                // remove the space
                row = row.substr(6);
              }
              displayCode[index] = row;
            });

            displayCode = displayCode.join('\n');
          }

          codeEditor.setValue(displayCode);

          // tell codeEditor to update the method when code is changed
          codeEditor.methodName = methodName;
          codeEditor.currentMethod = el['methodName'];

          codeEditor.mirror.on('change', function(e) {

            self.updateCode(e);

          });

          // this.updateCode();

        }
        else {
          codeEditor.setValue('//selected element has no public methods');
          // this.$.methodDropdown.$.label.innerHTML = 'No Method Selected';
          // console.log(this.$.methodDropdown);
          // this.$.methodDropdown.label = 'No Method Selected';

          codeEditor.mirror.on('change', function(e) {

          });
        }

      },

      updateCode: function(x) {

        var codeEditor = this.$.codeeditor;
        var methodName = this._selectedMethod;
        var currentMethod = codeEditor.currentMethod;
        // if there are no errors,

        // set currentMethod
        var newCode = codeEditor.getValue();
        var elMethod = this._selElement[methodName];

        // console.log(this);
        this._selElement[methodName] = Function(newCode).bind(this._selElement);

        if (this._autoUpdateCode && (audioContext.currentTime - this._lastCodeUpdate > this._codeUpdateFrequency) ) {
          this._selElement[methodName]();
          this._codeUpdateFrequency = audioContext.currentTime;
        }


        this._saveCustomMethod(this._selElement, methodName, newCode );
      },

      // SAVE CUSTOM METHODS

      _initCustomMethodsObj: function(elItem) {
        this._customMethods[elItem.id] = {};
      },

      _saveCustomMethod: function(element, methodName, code) {
        this._customMethods[element.id][methodName] = code;

        // TO DO - ensure that when elements are overwritten,
        // customMethods related to that element are deleted
      },

      _setupMethodDropdown: function(el) {
        var publicMethods = el.publicMethods;
        this._publicMethods = publicMethods;
        console.log('public methodz');
        console.log(this._publicMethods);
        if (typeof(this._publicMethods) !== 'undefined' && this._publicMethods.length > 0) {
          this._selectedMethod = this._publicMethods[0];
        }
      },

      // OBSERVER for selected element changed
      _selElementChanged: function() {

        // TO DO: if 'undefined' show global methods
        if (this._selElement === undefined) {
          // this._selElement = this;
          return;
        }

        // TO DO: figure out why this doesnt show as default
        this._selectedMethod = 'No Method Selected';
        this._setupMethodDropdown(this._selElement);
        this._listPublicMethods(this._selElement);
        this._showCode(this._selElement);

        // TO DO: bring back code here
        // this._methodChanged();

        // remove 'selected' class from other elements, add 'selected' class to this
        // this._selElement.className = this._selElement.className + ' selected';

        this._updateDocs(this._selElement);
      },

      /**
       *  update documentation
       */
      _updateDocs: function(element) {
        var pathToHTML = '../' + element.name +'/'+ element.name + '.html';
        this.$.docViewer.url = pathToHTML;
      },

      _methodChanged: function(e, detail) {
        var self = this;
        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
        this._selectedMethod = detail.item.getAttribute('label');
        this._showCode(this._selElement);
      },

      // called when the tab to view this element's code is clicked
      _elCodeButtonClicked: function(e) {
        var self = this;
        self.$.codeDialog.toggle();

        // TO DO: figure out why this is necessary
        setTimeout( function() {
          self.$.codeeditor.refresh();
          self._showCode(this._selElement);
        }, 400);
      },

      _elInfoButtonClicked: function(e) {
        this.$.infoDialog.toggle()
      },

      _mouseLeaveOutput: function(e) {
        // e.path[0].
        console.log('leave');
      },

      _mouseEnterOutput: function(e) {
        console.log('enter');
      },

      // KEY EVENTS
      keydownHandler: function(e) {
        this.keypressHandler(e);
      },

      keypressHandler: function(e) {
        var self = this;
        var focusedArea = e.path['0'].localName;

        // make sure it is not a text or input area
        if ( focusedArea.indexOf('text') > -1 || focusedArea.indexOf('input') > -1) {
          // in a text area, do nothing
          return;
        }

        switch(e.which) {
          // if deleteKey:
          case(8):
            e.preventDefault();
            e.stopPropagation();
            // if bezier was selected, delete that. Otherwise, delete element
            if (self.bezier) {
              self.deleteConnection();
            } else {
              self._deleteElement(self._selElement.id);
            }
            break;

          // zoom with -_ (189) and += (187)
          case(189):
            self.zoomOut();
            break;

          case(187):
            self.zoomIn();
            break;

          case(18):
            console.log('option key');
          default:
            break;
        } 
      },

      // SAVE AND LOAD SESSIONS
      // _environmentSave: function() {
      //   var olosData = {
      //     "elements" : this._elements,
      //     "connections": this._connections
      //   }
      //   console.log(olosData);
      // },

      // _environmentLoad: function() {

      // },

      _environmentClear: function() {
        var j;

        if(confirm('Are you sure you want to clear your entire sketch?')) {
          // dispose of every element
          for (var j = this._elements.length -1 ; j > 0 ; j--) {
            if (j === 0) {
              return
            }
            console.log(this._elements[j].id);
            this._deleteElement(this._elements[j].id);
          }

          // delete any remaining connections
          for (j = this._connections.length -1 ; j > 0 ; j--) {
            this._deleteAudioConnection(this._connections[i]);
          }

          // re-initialize variables:
          this._selElement = undefined;
          this._highlightedConnection = undefined;
          this.connections = [];
        }
      },

      _connectionsChanged: function() {
        console.log('connections changed');
        this._drawConnections();
      },


      // ===========                  ===================
      //           |*|  ANIMATION  |*|
      // via http://stackoverflow.com/a/19772220/2994108
      animate: function(_fps){
        var self = this;
        var fps = _fps || 15;
        var fpsInterval = 1000/fps;
        var then = Date.now();
        var startTime = then;
        var elapsed;
        var animationReq;

        self._animationLoop = function(timestamp) {
          now = Date.now();
          elapsed = now - then;
          animationReq = requestAnimationFrame(self._animationLoop);

          if (elapsed > fpsInterval) {
            then = now - (elapsed % fpsInterval);

            self.clock._draw();

            for (var i = 0; i < self._elements.length; i++) {
              if (typeof(self._elements[i].element._draw) !== 'undefined') {
                self._elements[i].element._draw();
              }
            }
          }
        }

        self.cancelAnimation = function() {
          window.cancelAnimationFrame(animationReq);
        }

        self._animationLoop(self._startTime);
      },


      // handle global code

      showGlobalBtn: function() {
        // this.$.globalDialog.toggle();
        this._selElement = this;

        this._showCode(this);
        this.$.codeDialog.toggle();

      },

      // public methods
      globalCode: function() {
        //hello world!
      },

      globalScale: function() {
        this.scale = [0, 2, 4, 5, 7, 9];
        this.root = "C#"
      },

      globalClock: function() {
        //hello world!
      },


      // globalCodeOpacityChanged: function() {
      //   this.$.globalDialog.style.opacity = this.globalCodeOpacity;
      //   // this.globalstyle="opacity:{{globalCodeOpacity}}; position:absolute;"
      // },

      codeOpacityChanged: function() {
        // this.$.codeDialog.style.opacity = this.codeOpacity;
        this.$.dialogWrapper.style.opacity = this.codeOpacity;
        this.$.codeDialog.style.backgroundColor = 'rgba(27,205,200,' + String(1.5 * this.codeOpacity) + ')';
      },

      // toggle whether code updates automatically, or only when you hit Run
      toggleAutoUpdateCode: function(e, detail, selection) {
        this._autoUpdateCode = selection.checked;
      },

      // export the source code
      _saveAsCode: function() {
        var self = this;
        var filename = self.$.filename.value || 'untitled';
        var output = [];

        output.push('/** \n *  '+ filename + '\n' + ' *  Created ' + String(new Date()) + '\n' + ' *  View Source: http://olos.cc/213798 \n **/ \n \n');

        loadStrings('output.js', function(str) {
          for (var i = 0; i < str.length; i++) {
            output.push( str[i] + '\n' );
          }

          p5.prototype.writeFile(output, filename, 'js');
        });

        // var customMethKeys = Object.keys(this._customMethods);

        // output.push('var ac = new AudioContext(); \n');
        // console.log(output);
        // for (var i = 0; i < customMethKeys.length; i) {
        //   output.push( String( customMethKeys[i] ) + ' = ac.createOscillator(); \n' );
        // }

        // p5.prototype.writeFile(output, 'myThing', 'js');
      }

    });
  </script>
</polymer-element>
